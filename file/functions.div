#!/bin/sh
#bof

# Diversion is free to use under the GNU General Public License version 3 (GPL-3.0)
# https://opensource.org/licenses/GPL-3.0

# Proudly coded by thelonelycoder
# Copyright (c) 2016-2066 thelonelycoder - All Rights Reserved
# https://www.snbforums.com/members/thelonelycoder.25480/
# https://diversion.ch

# Contributors:
# @Martineau in function list_files(): Fix 1 of 1 - Allow $ and spaces in file names, inspiration for file display with package column
# @bengalih in function edit_list(): Additional code for near matches in whitelist

# Script Version 4.1.11

if [ -f "${DIVERSION_DIR}/file/functions.local" ]; then
	. "${DIVERSION_DIR}/file/functions.local"
else
	write_bf(){

Minimal_list='http://winhelp2002.mvps.org/hosts.txt'

Small_list='https://someonewhocares.org/hosts/zero/hosts
https://pgl.yoyo.org/adservers/serverlist.php?hostformat=hosts&showintro=0&mimetype=plaintext&useip=0.0.0.0
https://raw.githubusercontent.com/hoshsadiq/adblock-nocoin-list/master/hosts.txt'

Standard_list='https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts'

Medium_list='https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts
https://hostfiles.frogeye.fr/firstparty-trackers-hosts.txt'

Large_list='https://hosts.oisd.nl/'

		if [ "$1" = "fs" ]; then
			case "$bfTypeFs" in
				Minimal) 		echo "${Minimal_list}" > "${DIVERSION_DIR}/list/hostslist_fs";;
				Small) 			echo "${Small_list}" > "${DIVERSION_DIR}/list/hostslist_fs";;
				Standard) 		echo "${Standard_list}" > "${DIVERSION_DIR}/list/hostslist_fs";;
				Medium) 		echo "${Medium_list}" > "${DIVERSION_DIR}/list/hostslist_fs";;
				Large) 			echo "${Large_list}" > "${DIVERSION_DIR}/list/hostslist_fs";;
			esac
		else
			case "$bfType" in
				Minimal) 		echo "${Minimal_list}" > "${DIVERSION_DIR}/list/hostslist";;
				Small) 			echo "${Small_list}" > "${DIVERSION_DIR}/list/hostslist";;
				Standard) 		echo "${Standard_list}" > "${DIVERSION_DIR}/list/hostslist";;
				Medium) 		echo "${Medium_list}" > "${DIVERSION_DIR}/list/hostslist";;
				Large) 			echo "${Large_list}" > "${DIVERSION_DIR}/list/hostslist";;
			esac
		fi
	}
fi

au_function(){
	printf "${INFO} Ads counter auto-update info\\n"
	printf "${SPACE} Counts ads when opening the UI\\n"
	echo
	if [ "$adsCounter" = "off" ] ; then
		printf " Ads counter auto-update off\\n"
		qestion=Enable
	else
		printf " Ads counter auto-update ${GREEN}on${NC}\\n"
		qestion=Disable
	fi
	while true; do
		printf "\\n $qestion auto-update? [1=Yes e=Exit] ";read -r continue
		case "$continue" in
			1)	[ "$adsCounter" = "off" ] && adsCounter=on || adsCounter=off
				lastAction=" Ads counter auto-update set to $adsCounter"
				write_conf_file;break;;
		 [Ee])	reload_menu;break;;
			*)	printf "\\n input is not an option\\n";;
		esac
	done
}

check_for_update(){
	rm -f /tmp/diversion.info
	_curl "$DIVERSION_URL/diversion.info" -o /tmp/diversion.info

	if [ -f "/tmp/diversion.info" ] && grep -wq '^#bof' /tmp/diversion.info && grep -wq '^#eof' /tmp/diversion.info; then
		unset S_VERSION S_M_VERSION
		. /tmp/diversion.info
		[ "$S_M_VERSION" ] && SERVER_VERSION="${S_VERSION}.$S_M_VERSION" || SERVER_VERSION=$S_VERSION
		version_check(){ echo "$@" | awk -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }';}
		rm -f /tmp/diversion.info

		if [ "$(version_check $SERVER_VERSION)" -gt "$(version_check $VERSION)" ]; then
			echo "$INFO ${GREEN}$NAME $SERVER_VERSION${NC} is now available!"
			echo "$SPACE Released on: $S_RELEASED"
			echo
			echo "$SPACE ${GREEN}What's new in $NAME $SERVER_VERSION${NC}"
			echo "$UI_UPDATE_TEXT"

			while true; do
				printf "\\n Do you want to update now? [1=Yes e=Exit] ";read -r continue
				case "$continue" in
					1)	VERSION=${S_VERSION};action=update;break;;
				 [Ee])	exit_message;reload_menu;break;;
					*)	printf "\\n input is not an option\\n\\n";;
				esac
			done
		else
			localmd5="$(md5sum "/opt/bin/$SELF" | awk '{print $1}')"
			remotemd5="$(/usr/sbin/curl -fsL --retry 3 "$DIVERSION_URL/${VERSION}/$SELF" | md5sum | awk '{print $1}')"
			if [ "$localmd5" != "$remotemd5" ]; then
				echo "$INFO A minor update is available for $NAME,"
				echo "$SPACE no version change."
				while true; do
					printf "\\n Do you want to update now? [1=Yes e=Exit] ";read -r continue
					case "$continue" in
						1)	VERSION=${S_VERSION};action=update;break;;
					 [Ee])	exit_message;reload_menu;break;;
						*)	printf "\\n input is not an option\\n";;
					esac
				done
			else
				echo "$INFO No update found for $NAME"
				while true; do
					printf "\\n Do you want to force update? [1=Yes e=Exit] ";read -r continue
					case "$continue" in
						1)	VERSION=${S_VERSION};action=update;break;;
					 [Ee])	exit_message;reload_menu;break;;
						*)	printf "\\n input is not an option\\n";;
					esac
				done
			fi
		fi

	else
		lastError=" Failed to retrieve version info from\\n $(echo $DIVERSION_URL | awk -F[/:] '{print $4}')"
		reload_menu
	fi
}

change_bf(){
	if [ "$1" = "fs" ]; then
		[ -z "$bfTypeFs" ] && currBFtype=none || currBFtype=$bfTypeFs
	else
		currBFtype=$bfType
	fi
	print_red_line
	echo " Select predefined blocking list to use.
 Your current type is ${GREEN}$currBFtype${NC}

 1. Minimal
    winhelp2002.mvps.org.
    Blocks ads and badware only.
    Filesize: ~220 KB, ~10,500 blocked domains.

 2. Small
    someonewhocares.org, pgl.yoyo.org,
    github.com/hoshsadiq/adblock-nocoin-list.
    Restricted blocking of Ads.
    Filesize: ~340 KB, ~17,900 blocked domains.

 3. Standard
    github.com/StevenBlack adware + malware.
    Good mix of blocked domains.
    Filesize: ~840 KB, ~54,200 blocked domains.

 4. Medium
    github.com/StevenBlack, adware + malware.
    hostfiles.frogeye.fr, first-party trackers.
    Comprehensive list of blocked domains.
    Filesize: ~1,8 MB, ~91,000 blocked domains.

 5. Large
    hosts.oisd.nl
    Very well maintained large hosts file, see
    redd.it/dwxgld
    Filesize: ~23 MB, ~1,100,000 blocked domains."

	if [ -z "$swaplocation" ]; then
		echo
		echo "${INFO} A swap file is recommended with a large"
		echo "${SPACE} blocking list."
		echo "${SPACE} Use ${RED_BG}sw${NC} to create it in $NAME."
	fi
	if [ "$bfType" = "Custom" ]; then
		echo
		echo "${ATTN} The Custom hosts list will be replaced by"
		echo "${SPACE} the selected predefined list."
		echo "${SPACE} This cannot be undone."
	fi
	while true; do
		printf "\\n Set new type: [1-5 e=Exit] ";read -r continue
		case "$continue" in
			1)		[ "$1" = "fs" ] && bfTypeFs=Minimal || bfType=Minimal;break;;
			2)		[ "$1" = "fs" ] && bfTypeFs=Small || bfType=Small;break;;
			3)		[ "$1" = "fs" ] && bfTypeFs=Standard || bfType=Standard;break;;
			4)		[ "$1" = "fs" ] && bfTypeFs=Medium || bfType=Medium;break;;
			5)		[ "$1" = "fs" ] && bfTypeFs=Large || bfType=Large;break;;
			[Ee]) 	exit_message;reload_menu;break;;
			*)	printf "\\n input is not an option\\n\\n";;
		esac
	done
	[ "$1" = "fs" ] && write_bf fs || write_bf
}

b_function(){
	printf " Blocking list options\\n\\n The ${GREEN}blocking list${NC} is assembled from hosts file(s)\\n and is the main ad-blocker in $NAME.\\n"
	printf " To fine tune the blocking list, use the edit list\\n options in ${RED_BG} el ${NC}.\\n\\n"

	if [ "$bfFs" = "on" ]; then
		echo " 1. Change composition ${bfColor}$bfType${NC} / ${bfColor}$bfTypeFs${NC} ${RED_BG} fs ${NC}"
	else
		echo " 1. Change composition ${bfColor}$bfType${NC} ${RED_BG} fs ${NC}"
	fi
	if [ -z "$domainsPerLine" ]; then
		echo " 2. Domains per line in blocking list(s), ${GREEN}20${NC} (default)"
	else
		echo " 2. Domains per line in blocking list(s), ${GREEN}$domainsPerLine${NC}"
	fi
	echo " 3. Change update day(s) and time"
	if [ "$bfFs" = "on" ]; then
		echo " 4. Update both blocking lists now ${RED_BG} bu ${NC}"
	else
		echo " 4. Update blocking list now ${RED_BG} bu ${NC}"
	fi
	echo " 5. Find domain in hosts file(s)"
	if [ "$alternateBF" = "on" ]; then
		echo " 6. Alternate blocking list, ${GREEN}enabled${NC}"
		[ "$bfFs" = "off" ] && echo "    (off, ${RED_BG} fs ${NC} is disabled)"
	else
		[ "$aBFIP" ] && echo " 6. Alternate blocking list, ${RED}disabled${NC}"
		[ -z "$aBFIP" ] && echo " 6. Alternate blocking list for specified clients"
	fi

	if [ "$LANblockingIP" = "on" ]; then
		echo " 7. LAN blocking IP address, ${GREEN}enabled${NC} on $lanBIP"
	else
		if [ -z "$lanBIP" ]; then
			echo " 7. Use LAN blocking IP address (advanced setting)"
		else
			echo " 7. LAN blocking IP address, ${RED}disabled${NC} $lanBIP"
		fi
	fi

	while true; do
		printf "\\n Enter selection [1-7 e=Exit] ";read -r continue
		case "$continue" in
			1)	read_conf_file
				prevbfType=$bfType
				prevbfFsType=$bfTypeFs
				edited_hostslist=
				print_red_line
				bsel=3
				echo " 1. Select a predefined list"
				echo " 2. Customize hosts list"
				if [ "$bfFs" = "on" ]; then
					echo " 3. ${RED}Disable${NC} ${bfColor}$bfTypeFs${NC} blocking list fast switch ${RED_BG} fs ${NC}"
					[ "$alternateBF" = "on" ] && echo "    (this also disables the Alternate blocking list)"
					if [ -f "/jffs/scripts/firewall" ] && grep -q "sh /jffs/scripts/firewall" /jffs/scripts/firewall-start 2> /dev/null; then
						bsel=4
						skynetcfg="$(grep -ow "skynetloc=.* # Skynet" /jffs/scripts/firewall-start 2>/dev/null | grep -vE "^#" | awk '{print $1}' | cut -c 11-)/skynet.cfg"
						if [ "$SkynetFs" = "on" ]; then
							echo " 4. ${RED}Disable${NC} Skynet fast switch"
						else
							echo " 4. ${GREEN}Enable${NC} Skynet fast switch"
						fi
					fi
				else
					echo " 3. ${GREEN}Enable${NC} blocking list fast switch ${RED_BG} fs ${NC}"
				fi
				while true; do
					printf "\\n Enter your selection: [1-$bsel e=Exit] ";read -r continue
					case "$continue" in
						1)		if [ "$bfFs" = "on" ]; then
									print_red_line
									echo " 1. Change primary blocking list ${bfColor}$bfType${NC}"
									echo " 2. Change secondary blocking list ${bfColor}$bfTypeFs${NC}"
									while true; do
										printf "\\n Enter your selection: [1-2 e=Exit] ";read -r continuefs
										case "$continuefs" in
											1)		change_bf;break;;
											2)		change_bf fs;break;;
											[Ee]) 	exit_message;reload_menu;break;;
											*)		printf "\\n input is not an option\\n";;
										esac
									done
								else
									change_bf
								fi
								break;;
						2)		if [ "$bfFs" = "on" ]; then
									print_red_line
									echo " 1. Customize primary list ${bfColor}$bfType${NC}"
									echo " 2. Customize secondary list ${bfColor}$bfTypeFs${NC}"
									while true; do
										printf "\\n Enter your selection: [1-2 e=Exit] ";read -r continuefs
										case "$continuefs" in
											1)		b_customize;break;;
											2)		b_customize fs;break;;
											[Ee]) 	exit_message;reload_menu;break;;
											*)		printf "\\n input is not an option\\n";;
										esac
									done
								else
									b_customize
								fi
								break;;
						3)		read_conf_file
								if [ "$bfFs" = "on" ]; then
									[ "$bfTypeinUse" = "secondary" ] && restartD=1 || restartD=0
									[ "$alternateBF" = "on" ] && restartD=1
									bfFs=off
									bfTypeinUse=primary
									SkynetFs=off
									write_conf_file
									[ "$restartD" = "1" ] && restart_DNSMASQ
									lastAction=" blocking list fast switch disabled"
								else
									bfFs=on
									change_bf fs
									[ -z "$bfTypeinUse" ] && bfTypeinUse=primary
									write_conf_file
									if [ -f "${DIVERSION_DIR}/list/blockinglist_fs" ] && [ "$(find ${DIVERSION_DIR}/list/blockinglist_fs -mtime +6)" ]; then
										if [ "$(ps | grep -v grep | grep update-bl.div)" ]; then
											lastError=" Blocking list update already runs in the\\n background. Please update list manually later."
										else
											echo
											echo "${INFO} Running update-bl.div for secondary blocking list"
											echo "${INFO} Existing file is older than 6 days"
											echo "${GRAY}"
											sh "${DIVERSION_DIR}/file/update-bl.div" secondary
											echo "${NC}"
										fi
									else
										[ "$alternateBF" = "on" ] && restart_DNSMASQ
									fi
									lastAction=" blocking list fast switch ${NC}${RED_BG} fs ${NC}${GREEN} enabled${NC}"
								fi
								break;;
						4)		if [ "$bsel" = "3" ]; then
									lastError=" Skynet is not installed on this router"
									reload_menu
								fi
								read_conf_file
								if [ "$bfFs" = "on" ]; then
									if [ "$SkynetFs" = "on" ]; then
										SkynetFs=off
										write_conf_file
										lastAction=" Skynet fast switch set to $SkynetFs"
									else
										if grep -q "customlist2url=\"\"" $skynetcfg; then
											lastError=" Enable Skynet fast switch first"
											reload_menu
										elif grep -q "customlist2url=\".*\"" $skynetcfg; then
											SkynetFs=on
											write_conf_file
											lastAction=" Skynet fast switch set to $SkynetFs"
										else
											lastError=" Update Skynet and enable fast switch first"
											reload_menu
										fi
									fi
								else
									lastError=" Enable blocking list fast switch first"
								fi
								break;;
						[Ee]) 	exit_message;reload_menu;;
						*)		printf "\\n input is not an option\\n";;
					esac
				done

				[ "$edited_hostslist" = "edited_hl" ] && bfType=Custom
				[ "$edited_hostslist" = "edited_hlfs" ] && bfTypeFs=Custom

				if [ "$prevbfType" != "$bfType" ] || [ "$prevbfFsType" != "$bfTypeFs" ] || [ "$edited_hostslist" ]; then

					print_red_line
					printf "${ATTN} The blocking list composition changed\\n"

					while true; do
						printf "\\n Update list now? (recommended) [1=Yes 2=No] ";read -r continue
						case "$continue" in
							1)	echo
								write_conf_file
								if [ "$prevbfType" != "$bfType" ] && [ "$prevbfFsType" != "$bfTypeFs" ]; then
									updBF=both
								elif [ "$prevbfType" != "$bfType" ]; then
									updBF=primary
								elif [ "$prevbfFsType" != "$bfTypeFs" ]; then
									updBF=secondary
								fi
								if [ "$(ps | grep -v grep | grep update-bl.div)" ]; then
									lastError=" Blocking list update already runs in the\\n background. Please update list manually later."
								else
									echo "${INFO} Running update-bl.div for $updBF blocking list(s)"
									echo "${GRAY}"
									sh "${DIVERSION_DIR}/file/update-bl.div" $updBF
									echo "${NC}"
									lastAction=" blocking list composition changed"
								fi
								break;;
							2)	bfUpdatePrevRun=$bfUpdateLastRun
								write_conf_file
								lastAction=" blocking list composition changed"
								lastAction="$lastAction \\n ${NC}${RED}Domain count off until blocking list update is run${NC}"
								break;;
							*)	printf "\\n input is not an option\\n";;
						esac
					done

				else
					[ -z "$lastAction" ] && [ -z "$lastError" ] && lastAction=" blocking list reviewed, no change"
				fi
				break;;
		dpl|2)	print_red_line
				[ -z "$domainsPerLine" ] && oldDPL=20 || oldDPL=$domainsPerLine
				printf "${INFO} This sets the number of mapped domains to IP\\n${SPACE} per line in the blocking list(s).\\n\\n"
				[ -z "$domainsPerLine" ] && echo " Current setting is default (20)" || echo " Current setting is: ${GREEN}$domainsPerLine${NC}"
				printf "\\n 0    Reset to default (20 domains)\\n 1-25 Set domains per line.\\n"
				while true; do
					printf "\\n${RED_BG} Enter number ${NC} [0-25 e=Exit] ";read -r dplv
					case "$dplv" in
						[1-9]|[1][0-9]|[2][0-5])	domainsPerLine=$dplv
													lastAction=" Domain per line set to $domainsPerLine"
													write_conf_file
													if [ "$oldDPL" != "$domainsPerLine" ] && [ ! "$(ps | grep -v grep | grep update-bl.div)" ]; then
														echo
														echo "${INFO} Running update-bl.div for changes to take effect"
														echo "${GRAY}"
														sh "${DIVERSION_DIR}/file/update-bl.div"
														echo "${NC}"
														edited_whitelist=
														edited_blacklist=
														edited_wc_blacklist=
														write_conf_file
													fi
													reload_menu
													break;;
						0)							domainsPerLine=
													lastAction=" Domain per line set to 20 (default)"
													write_conf_file
													if [ "$oldDPL" != "20" ] && [ ! "$(ps | grep -v grep | grep update-bl.div)" ]; then
														echo
														echo "${INFO} Running update-bl.div for changes to take effect"
														echo "${GRAY}"
														sh "${DIVERSION_DIR}/file/update-bl.div"
														echo "${NC}"
														edited_whitelist=
														edited_blacklist=
														edited_wc_blacklist=
														write_conf_file
													fi
													reload_menu
													break;;
						[Ee])						exit_message;reload_menu
													break;;
						*)							printf "\\n input is not an option\\n";;
					esac
				done
				break;;
			3)	read_conf_file
				print_red_line
				printf " ${GREEN}Only set by Day OR by Twice a week${NC}.\\n\\n"
				printf " Day                   Twice a week\\n"
				printf " ------------    OR    --------------------------\\n"
				printf " 1. Monday             91. Monday & Thursday\\n"
				printf " 2. Tuesday            92. Tuesday & Friday\\n"
				printf " 3. Wednesday          93. Wednesday & Saturday\\n"
				printf " 4. Thursday           94. Thursday & Sunday\\n"
				printf " 5. Friday             95. Friday & Monday\\n"
				printf " 6. Saturday           96. Saturday & Tuesday\\n"
				printf " 7. Sunday             97. Sunday & Wednesday\\n"

				while true; do
					printf "\\n Select update day(s): [1-7 OR 91-97 e=Exit] ";read -r updday
					case "$updday" in
						1)		bfUpdateDay=Monday;bfUpdateDOW=Mon;break;;
						2)		bfUpdateDay=Tuesday;bfUpdateDOW=Tue;break;;
						3)		bfUpdateDay=Wednesday;bfUpdateDOW=Wed;break;;
						4)		bfUpdateDay=Thursday;bfUpdateDOW=Thu;break;;
						5)		bfUpdateDay=Friday;bfUpdateDOW=Fri;break;;
						6)		bfUpdateDay=Saturday;bfUpdateDOW=Sat;break;;
						7)		bfUpdateDay=Sunday;bfUpdateDOW=Sun;break;;
						91)		bfUpdateDay="Monday, Thursday";bfUpdateDOW="Mon,Thu";break;;
						92)		bfUpdateDay="Tuesday, Friday";bfUpdateDOW="Tue,Fri";break;;
						93)		bfUpdateDay="Wednesday, Saturday";bfUpdateDOW="Wed,Sat";break;;
						94)		bfUpdateDay="Thursday, Sunday";bfUpdateDOW="Thu,Sun";break;;
						95)		bfUpdateDay="Friday, Monday";bfUpdateDOW="Fri,Mon";break;;
						96)		bfUpdateDay="Saturday, Tuesday";bfUpdateDOW="Sat,Tue";break;;
						97)		bfUpdateDay="Sunday, Wednesday";bfUpdateDOW="Sun,Wed";break;;
						[Ee]) 	exit_message;reload_menu;;
						*) 	printf "\\n input is not an option\\n";;
					esac
				done
				print_red_line
				printf " Select the time the update should run on $bfUpdateDay:\\n\\n"
				printf "  1.  1:00 (1:00 would be 1 a.m.)\\n  2.  2:00\\n  3.  3:00\\n"
				printf "  4.  4:00\\n  5.  5:00\\n  6.  6:00\\n  8.  8:00\\n 10. 10:00\\n 12. 12:00\\n"
				while true; do
					printf "\\n Select update hour: [1-12] ";read -r bfUpdateHour
					case "$bfUpdateHour" in
						1)	break;;
						2)	break;;
						3)	break;;
						4)	break;;
						5)	break;;
						6)	break;;
						8)	break;;
					   10)	break;;
					   12)	break;;
						*)	printf "\\n input is not an option\\n";;
					esac
				done
				write_conf_file
				restart_DNSMASQ
				lastAction=" blocking list update set to\\n $bfUpdateDay @ ${bfUpdateHour}:00"
				reload_menu;break;;
			4)	if [ "$(ps | grep -v grep | grep update-bl.div)" ]; then
					lastError=" Blocking list update already runs in the\\n background"
				else
					echo
					echo "${INFO} Running update-bl.div"
					echo "${GRAY}"
					sh "${DIVERSION_DIR}/file/update-bl.div"
					echo "${NC}"
					edited_whitelist=
					edited_blacklist=
					edited_wc_blacklist=
					[ "$bfFs" = "on" ] && lastAction=" blocking lists updated" || lastAction=" blocking list updated"
				fi
				break;;
			5)	print_red_line
				printf "${INFO} This finds in which hosts file(s)\\n${SPACE} a domain is blocked.\\n"
				printf "\\n${RED_BG} Enter domain ${NC} [e=Exit] ";read -r listadd
				case "$listadd" in
					[Ee])	echo
							b_function
							;;
					   *)	listadd=$(echo $listadd | sed 's#http[s]*://##;s#/.*##')
							greplistadd=$(echo $listadd | sed -e 's/\./\\./g')
							if /opt/bin/grep -qP  "\s$greplistadd$|\s$greplistadd\r$" "${DIVERSION_DIR}/backup"/hostsfile_*; then
								printf "\\n ${GREEN}$listadd${NC}\\n was found in the following list(s):\\n"
								echo "${GREEN}"
								/opt/bin/grep -Pl "\s$greplistadd$|\s$greplistadd\r$" "${DIVERSION_DIR}/backup"/hostsfile_* | sed -e "s~$DIVERSION_DIR/backup/hostsfile_~~;s/^/ /"
								echo "${NC}"
							else
								printf "\\n no matches found in used hosts files\\n"
							fi
							press_enter_to "return to menu"
							;;
				esac
				b_function
				break;;
			6)	read_conf_file
				if [ "$bfFs" = "on" ]; then
					if [ -z "$aBFIP" ]; then
						print_red_line
						printf " This enables the alternate blocking list.\\n\\n"
						printf " 1. Enable alternate blocking list\\n"

						while true; do
							printf "\\n Enter your selection [1-1 e=Exit] ";read -r continue
							case "$continue" in
								1)	break;;
							 [Ee])	exit_message;reload_menu;break;;
								*)	printf "\\n input is not an option\\n";;
							esac
						done
						print_red_line

						if [ -z "$(grep -o "swapon .*" /jffs/scripts/post-mount | awk '{print $2}')" ]; then
							echo "${INFO} A swap file is required with the alternate"
							echo "${SPACE} blocking list enabled."
							echo
							printf " 1. Create swap file now\\n"
							printf " 2. Decline swap file creation\\n"
							while true; do
								printf "\\n Enter your selection [1-1 e=Exit] ";read -r continue
								case "$continue" in
									1)	print_red_line
										skiprl=1
										sw_function
										printf "${GREEN}$lastAction${NC}\\n\\n"
										lastAction=
										print_red_line
										break;;
									2)	lastError=" Declined swap file creation, alternate\\n blocking list not enabled"
										reload_menu;break;;
								 [Ee])	exit_message;reload_menu;break;;
									*)	printf "\\n input is not an option\\n";;
								esac
							done
						fi
						if [ "$psIP" ]; then
							printf "${INFO} Reserving additional IP address for alternate\\n${SPACE} Dnsmasq instance.\\n"
							printf "${SPACE} Note: This is in addition to the already\\n${SPACE} reserved pixelserv-tls IP ${GREEN}$psIP${NC}\\n\\n"
							sIP=4
						else
							printf "${INFO} Reserving one IP address for alternate Dnsmasq\\n${SPACE} instance\\n\\n"
							sIP=3
						fi
						printf "${ATTN} DO THIS NOW: Log into this routers WebUI\\n\\n"
						echo ' - Go to LAN > DHCP Server'
						echo ' - Adjust "IP Pool Starting Address" from the'
						echo '   standard xxx.xxx.xxx.2 (typically 192.168.1.2)'
						echo "   to xxx.xxx.xxx.$sIP (e.g 192.168.1.$sIP),"
						echo "   xxx.xxx.xxx.$((sIP-1)) would be the reserved address"
						echo ' - Make sure the reserved address is not used'
						echo '   by your other devices'
						echo ' - Then click "Apply"'
						echo
						echo " You will need to enter the IP address next"
						press_enter_to "continue when ready"

						print_red_line

						otherIP=
						otherSV=

						if [ "$psIP" ]; then
							otherIP=$psIP
							otherSV="pixelserv-tls IP"
						fi

						get_file install.div include >/dev/null
						select_ip "alternate Dnsmasq IP"
						aBFIP=$setIP

						acknotice=1
						set_access_restriction $aBFIP "alternate Dnsmasq IP"
						get_file alternate-bf.div new

						alternateBF=on
						lastAction=" Alternate blocking list enabled"
						[ -z "$adsBlockedAlt" ] && adsBlockedAlt=0
						[ -z "$adsWeekAlt" ] && adsWeekAlt=0
						[ -z "$adsNewAlt" ] && adsNewAlt=0
						write_conf_file
						restart_DNSMASQ
					else
						print_red_line
						if [ "$alternateBF" = "on" ]; then
							echo " 1. ${RED}Disable${NC} alternate blocking list"
						else
							echo " 1. ${GREEN}Enable${NC} alternate blocking list"
						fi
						echo " 2. Change alternate Dnsmasq IP ${GREEN}$aBFIP${NC}"
						abFsel=2
						if [ -f "/jffs/configs/dnsmasq.conf.add" ]; then
							abFsel=3
							if [ "$aBFConfInc" = "on" ]; then
								echo " 3. Include dnsmasq.conf.add ${GREEN}$aBFConfInc${NC}"
							else
								echo " 3. Include dnsmasq.conf.add ${RED}off${NC}"
							fi
						fi
						while true; do
							printf "\\n Enter selection [1-$abFsel e=Exit] ";read -r continue
							case "$continue" in
								1)	if [ "$alternateBF" = "on" ]; then
										alternateBF=off
										ifconfig br0:alternate_bf $aBFIP down
										lastAction=" Alternate blocking list disabled"
										write_conf_file
										restart_DNSMASQ
									else
										alternateBF=on
										lastAction=" Alternate blocking list enabled"
										write_conf_file
										restart_DNSMASQ
									fi
									break;;
								2)	print_red_line
									printf " This changes the alternate Dnsmasq IP address.\\n\\n"
									printf " 1. Change alternate Dnsmasq IP [${GREEN}$aBFIP${NC}]\\n"
									while true; do
										entloop(){
											printf "\\n Enter your selection [1-1 e=Exit] ";read -r continue
											case "$continue" in
												1)	print_red_line
													oldaBFIP=$aBFIP
													get_file install.div include >/dev/null
													select_ip "alternate Dnsmasq IP"
													aBFIP=$setIP
													write_conf_file
													if [ "$(nvram get enable_acc_restriction)" = "1" ]; then
														nvram set restrict_rulelist=$(nvram get restrict_rulelist | sed "s|<1>$oldaBFIP>1||g")
														acknotice=1
														set_access_restriction $aBFIP "alternate Dnsmasq IP"
													fi
													ifconfig br0:alternate_bf $oldaBFIP down
													if [ "$alternateBF" = "on" ]; then
														restart_DNSMASQ
														lastAction=" alternate Dnsmasq IP changed from\\n $oldaBFIP to $aBFIP"
													fi
													break;;
											 [Ee])	exit_message;reload_menu;break;;
												*)	printf "\\n input is not an option\\n";;
											esac
											}
										entloop
									done
									break;;
								3)	if [ "$abFsel" = "3" ]; then
										if [ "$aBFConfInc" = "on" ]; then
											aBFConfInc=off
											lastAction=" dnsmasq.conf.add inclusion disabled"
										else
											aBFConfInc=on
											lastAction=" dnsmasq.conf.add inclusion enabled"
										fi
										write_conf_file
										if [ "$alternateBF" = "on" ]; then
											restart_DNSMASQ
										fi
									else
										exit_message;reload_menu
									fi
									break;;
							[Ee])	exit_message;reload_menu;break;;
								*)	printf "\\n input is not an option\\n";;
							esac
						done
					fi
				else
					lastError=" Enable blocking list fast switch${NC} ${RED_BG} fs ${NC}\\n${RED} first in ${NC} ${RED_BG} b ${NC}, 1."
				fi
				reload_menu
				break;;
			7)	read_conf_file

				select_LAN_IP(){
					printf " Enter $1 Address: ";read -r setIP

					dhcp_start=$(nvram get dhcp_start)
					dhcp_end=$(nvram get dhcp_end)
					lan_ipaddr=$(nvram get lan_ipaddr)

					if [ "$setIP" = "$lan_ipaddr" ]; then
						printf "\\n${NOK} $setIP is this routers IP address\\n\\n"
						select_LAN_IP "$1"
						return 1
					fi
					if ! expr "$setIP" : '[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*$' >/dev/null; then
						printf "\\n${NOK} $setIP is not a valid IP address\\n\\n"
						select_LAN_IP "$1"
						return 1
					fi
					if [ "$setIP" = 0.0.0.0 ] || [ "$setIP" = 127.0.0.1 ]; then
						printf "\\n${NOK} $setIP is not a LAN IP address\\n\\n"
						select_LAN_IP "$1"
						return 1
					fi
					if [ "$setIP" = "$psIP" ]; then
						printf "\\n${NOK} $setIP is this routers pixelserv-tls IP address\\n\\n"
						select_LAN_IP "$1"
						return 1
					fi
					if [ "$setIP" = "$aBFIP" ]; then
						printf "\\n${NOK} $setIP is this routers alternate pixelserv-tls IP address\\n\\n"
						select_LAN_IP "$1"
						return 1
					fi
					if [ "$(printf "$lan_ipaddr" | sed 's/\.[0-9]*$/./')" = "$(printf "$setIP" | sed 's/\.[0-9]*$/./')" ]; then

						if [ "${setIP##*.}" -lt 254 ] && [ "${setIP##*.}" -ge 1 ]; then
							printf "\\n${OK} $setIP is a valid LAN IP address\\n"
						else
							printf "\\n${NOK} $setIP is not a valid LAN IP address\\n\\n"
							select_LAN_IP "$1"
							return 1
						fi

					else
						printf "\\n${NOK} $setIP is an external IP address\\n\\n"
						select_LAN_IP "$1"
						return 1
					fi

					printf "${INFO} checking if $setIP is available to use\\n\\n"

					if ping -c2 -W5 "$setIP" >/dev/null; then
						printf "${OK} $1 address set to $setIP\\n"
					else
						print_red_line
						printf "${NOK} $setIP did not responded to ping\\n"
						printf "\\n${ATTN} Do not set $1 to an IP that\\n${SPACE} is not responding. This will not work!\\n\\n"
						printf " 1. Confirm this is the $1 address\\n"
						printf " 2. Select a different IP address\\n"
						while true; do
							printf "\\n Enter your selection [1-2 e=Exit] ";read -r continue
							case "$continue" in
								1)	printf "\\n${OK} $1 address set to $setIP\\n";break;;
								2)	echo
									select_LAN_IP "$1"
									return 1;break;;
							[Ee])	exit_message;reload_menu;break;;
								*)	printf "\\n input is not an option\\n";;
							esac
						done
					fi
				}

				switch_blocking_IP(){
					if [ "$LANblockingIP" = "on" ]; then
						blockingIP=$lanBIP
						if [ "$EN" -ge "2" ] && [ "$psState" = "on" ]; then
							on_off_pixelserv off
							prevPsState=off
						fi
						write_conf_file
						restart_DNSMASQ
					else
						if [ "$EN" -ge "2" ] && [ "$psState" = "off" ]; then
							blockingIP=$psIP
							psState=on
							prevPsState=on
							write_conf_file
							on_off_pixelserv on
						else
							blockingIP=0.0.0.0
							write_conf_file
						fi
						restart_DNSMASQ
					fi
				}

				if [ -z "$lanBIP" ]; then
					print_red_line
					printf " This enables the use of a non-router LAN blocking\\n IP address.\\n\\n${ATTN} This setting is for advanced users only.\\n\\n"
					[ "$EN" -ge "2" ] && printf "${ATTN} Enabling this will disable pixelserv-tls!\\n\\n"
					printf " 1. Enable LAN blocking IP address\\n"

					while true; do
						printf "\\n Enter your selection [1-1 e=Exit] ";read -r continue
						case "$continue" in
							1)	print_red_line
								select_LAN_IP "LAN blocking IP"
								LANblockingIP=on
								lanBIP=$setIP
								switch_blocking_IP
								lastAction=" LAN blocking IP enabled on $lanBIP"
								break;;
						 [Ee])	exit_message;reload_menu;break;;
							*)	printf "\\n input is not an option\\n";;
						esac
					done
					print_red_line
				else
					print_red_line
					if [ "$LANblockingIP" = "on" ]; then
						echo " 1. ${RED}Disable${NC} LAN blocking IP"
					else
						echo " 1. ${GREEN}Enable${NC} LAN blocking IP"
					fi
					echo " 2. Change LAN blocking IP ${GREEN}$lanBIP${NC}"

					while true; do
						printf "\\n Enter selection [1-2 e=Exit] ";read -r continue
						case "$continue" in
							1)	if [ "$LANblockingIP" = "on" ]; then
									LANblockingIP=off
									lastAction=" LAN blocking IP disabled"
								else
									LANblockingIP=on
									lastAction=" LAN blocking IP enabled"
								fi
								switch_blocking_IP
								break;;
							2)	print_red_line
								printf " This changes the LAN blocking IP address.\\n\\n"
								printf " 1. Change LAN blocking IP ${GREEN}$lanBIP${NC}\\n"
								while true; do
									entloop(){
										printf "\\n Enter your selection [1-1 e=Exit] ";read -r continue
										case "$continue" in
											1)	print_red_line
												oldlanBIP=$lanBIP
												select_LAN_IP "LAN blocking IP"
												lanBIP=$setIP
												if [ "$LANblockingIP" = "on" ]; then
													blockingIP=$lanBIP
													write_conf_file
													restart_DNSMASQ
												else
													write_conf_file
												fi
												lastAction=" LAN blocking IP changed from\\n $oldlanBIP to $lanBIP"
												break;;
										 [Ee])	exit_message;reload_menu;break;;
											*)	printf "\\n input is not an option\\n";;
										esac
										}
									entloop
								done
								break;;
						[Ee])	exit_message;reload_menu;break;;
							*)	printf "\\n input is not an option\\n";;
						esac
					done
				fi

				break;;
		 [Ee])	exit_message;reload_menu;break;;
			*) 	printf "\\n input is not an option\\n";;
		esac
	done
}

b_customize(){
	print_red_line
	fs=
	if [ "$1" = "fs" ]; then
		edit_hl=hostslist_fs
		edited_list=hlfs
		fs=fs
	else
		edit_hl=hostslist
		edited_list=hl
	fi

	printf " Customizable hosts list:\\n\\n"
	i=1
	cat "${DIVERSION_DIR}/list/$edit_hl" | while IFS= read line; do
		if echo "$line" | grep -q "^# "; then
			printf " $i: ${RED}$line${NC}\\n"
		else
			printf " $i: ${GREEN}$line${NC}\\n"
		fi
		i=$((i+1))
	done
	print_red_line
	printf " 1. Add hosts list\\n 2. Remove hosts list\\n 3. ${RED}Disable${NC} hosts list\\n 4. ${GREEN}Enable${NC} hosts list\\n"
	while true; do
		printf "\\n Enter selection [1-2 e=Exit] ";read -r continue
		case "$continue" in
			1)	while true; do
					printf "\\n${INFO} Hosts list can be in \"IP domain\" pair or\\n${SPACE} domain only format.\\n"
					printf "\\n Paste web address and press [Enter]\\n"
					printf "\\n${RED_BG} Enter hosts list ${NC} [q=Quit] ";read -r listadd
					case "$listadd" in
						[Qq])	b_customize $fs;break;;
						*)		if grep -q $listadd "${DIVERSION_DIR}/list/$edit_hl"; then
									printf "\\n${NOK} The entered hosts file address is a duplicate\\n"
									printf "${SPACE} of an existing entry.\\n"
									press_enter_to return
								else
									[ "$(echo "$listadd" | grep 'dropbox.com')" ] && [ "$(echo "$listadd" | grep 'dl=1')" ] && listadd="$(echo "$listadd" | sed "s~dl=1~dl=0~")"
									_curl --head -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0" "$listadd" | head -n 1 | grep "HTTP/1.[01] [23].." >/dev/null
									if [ "$?" = "0" ]; then
										[ "$(echo "$listadd" | grep 'dropbox.com')" ] && [ "$(echo "$listadd" | grep 'dl=0')" ] && listadd="$(echo "$listadd" | sed "s~dl=0~dl=1~")"
										edited_hostslist=edited_$edited_list
										echo "$listadd" >>"${DIVERSION_DIR}/list/$edit_hl"
									else
										printf "\\n${NOK} This address did not respond, check its validity.\\n"
										press_enter_to return
									fi
								fi
								b_customize $fs;break;;
					esac
				done;break;;
			2)	printf "\\n${RED_BG} Line number to remove ${NC} [q=Quit] ";read -r deleteline
				case $deleteline in
					[Qq])	b_customize $fs;break;;
					   *)	edited_hostslist=edited_$edited_list
							sed -i "${deleteline}d" "${DIVERSION_DIR}/list/$edit_hl"
							b_customize $fs;break;;
				esac
				break;;
			3)	printf "\\n${RED_BG} Line number to disable ${NC} [q=Quit] ";read -r deleteline
				case $deleteline in
					[Qq])	b_customize $fs;break;;
					   *)	edited_hostslist=edited_$edited_list
							sed -i "${deleteline}s/# //" "${DIVERSION_DIR}/list/$edit_hl"
							sed -i "${deleteline}s/.*/# &/" "${DIVERSION_DIR}/list/$edit_hl"
							b_customize $fs;break;;
				esac
				break;;
			4)	printf "\\n${RED_BG} Line number to enable ${NC} [q=Quit] ";read -r deleteline
				case $deleteline in
					[Qq])	b_customize $fs;break;;
					   *)	edited_hostslist=edited_$edited_list
							sed -i "${deleteline}s/# //" "${DIVERSION_DIR}/list/$edit_hl"
							b_customize $fs;break;;
				esac
				break;;
		 [Ee])  exit_message;break;;
			*)	printf "\\n input is not an option\\n";;
		esac
	done
}

c_function(){
	[ -z "$divUpdate" ] && DivUn=off || DivUn=DivUn
	[ -z "$backup" ] && bu=off || bu=backup
	if [ "$weeklyStats" = "on" ]; then
		stats=stats
		params=":$wsTo,$wsAs,$wsDo"
	else
		stats=off
		params=
	fi
	[ -z "$fwUpdate" ] && FWun=off || FWun=FWun
	echo " Communication settings"
	echo
	echo " 1. $NAME update notification ${divnColor}$DivUn${NC}"
	echo " 2. $NAME stats ${wsColor}$stats${NC}$params"
	echo " 3. $NAME backup ${buColor}$bu${NC}"
	echo " 4. Firmware update notification ${fwnColor}$FWun${NC}"
	echo " 5. Edit email settings, send testmail"
	while true; do
		printf "\\n Enter selection [1-5 e=Exit] ";read -r continue
		case "$continue" in
			1)	c_diversion_update;break;;
			2)	c_stats;break;;
			3)	c_backup;break;;
			4)	c_fw_update;break;;
			5)	c_email_edit;break;;
		 [Ee])	exit_message;reload_menu;break;;
			*) 	printf "\\n input is not an option\\n";;
		esac
	done
}

c_diversion_update(){
	print_red_line
	read_conf_file
	printf " $NAME update notification info:\\n\\n"
	printf " Checks weekly for updates.\\n Sends an email if update is available.\\n"
	echo

	if [ -z "$divUpdate" ] || [ "$divUpdate" = "off" ] ; then
		printf " 1. ${GREEN}Enable${NC} update notification\\n"
		upno=1
	else
		printf " 1. ${RED}Disable${NC} update notification\\n"
		printf " 2. Send test update notification\\n"
		upno=2
	fi

	while true; do
		printf "\\n Enter selection [1-$upno e=Exit] ";read -r continue
		case "$continue" in
			1)	if [ -z "$divUpdate" ] || [ "$divUpdate" = "off" ] ; then
					check_email_conf_file
					divUpdate=on
					echo
					get_file update.div new
					write_conf_file
					restart_DNSMASQ
					lastAction=" $NAME update notification enabled"
					c_diversion_update
				else
					divUpdate=off
					rm -f "${DIVERSION_DIR}/file/update.div"
					write_conf_file
					restart_DNSMASQ
					lastAction=" $NAME update notification disabled"
					reload_menu
				fi
				break;;
			2)	if [ -z "$divUpdate" ] || [ "$divUpdate" = "off" ] ; then
					lastError=" Enable update notification first"
					reload_menu
				else
					echo "${GRAY}"
					sh "${DIVERSION_DIR}/file/update.div" test
					echo "${NC}"
					lastAction=" Test update notification sent"
				fi
				reload_menu;break;;
		 [Ee])	reload_menu;break;;
			*)	printf "\\n input is not an option\\n";;
		esac
	done
}

c_stats(){
	print_red_line
	read_conf_file
	printf "${INFO} Router stats info\\n\\n"
	printf " Set weekly stats to on or off.\\n Edit settings or compile current stats.\\n"
	echo
	[ -z "$wsTopHosts" ] && wsTopHosts=10
	[ -z "$wsTopClients" ] && wsTopClients=10
	[ -z "$wsFilterLN" ] && wsFilterLN=off
	if [ -z "$weeklyStats" ] || [ "$weeklyStats" = "off" ] ; then
		printf " 1. ${GREEN}Enable${NC} Weekly stats\\n"
	else
		printf " 1. Weekly stats settings ($(echo $bfUpdateDay | sed 's/,.*//') @ $((bfUpdateHour-1)):30)\\n"
	fi
	printf " 2. Compile current stats report\\n"
	printf " 3. Top 'x' setting  Top ${GREEN}$wsTopHosts${NC} hosts for ${GREEN}$wsTopClients${NC} clients${NC}\\n"
	if [ "$wsFilterLN" = "off" ] ; then
		printf " 4. Filter local client names ${RED}$wsFilterLN${NC}\\n"
	else
		printf " 4. Filter local client names ${GREEN}$wsFilterLN${NC}\\n"
	fi
	printf " 5. Show local clients list, save names in backup\\n"
	if [ -z "$excludeIP" ] || [ "$excludeIP" = "off" ] ; then
		printf " 6. Exclude client IP address(es) in stats ${RED}off${NC}\\n"
		exoptColor="${RED}"
	else
		printf " 6. Exclude client IP address(es) in stats ${GREEN}$excludeIP${NC}\\n"
		exoptColor="${GREEN}"
	fi
	while true; do
		printf "\\n Enter selection [1-6 e=Exit] ";read -r continue
		case "$continue" in
			1)	on_off_weekly_stats;reload_menu;break;;
			2)	print_red_line
				run_current_stats;reload_menu;break;;
			3)	if [ -z "$weeklyStats" ]; then
					lastError=" Weekly stats are disabled, enable it first."
					reload_menu
				fi
				print_red_line
				printf " Select the value of top 'x'${GREEN} hosts${NC} the stats\\n"
				printf " should compile,${GREEN} currently set to: $wsTopHosts${NC}\\n\\n"
				printf " Note that a large blocking list greatly\\n affects stats creation time if set to high value.\\n"
				printf " 1.  5\\n 2. 10 (default)\\n 3. 15\\n 4. 20\\n 5. 25\\n 6. 30\\n 7. 35\\n 8. 40\\n"
				while true; do
					printf "\\n Set top 'x'${GREEN} hosts${NC} count [1-8 e=Exit] ";read -r tophost
					case "$tophost" in
						1)	wsTopHosts=5;break;;
						2)	wsTopHosts=10;break;;
						3)	wsTopHosts=15;break;;
						4)	wsTopHosts=20;break;;
						5)	wsTopHosts=25;break;;
						6)	wsTopHosts=30;break;;
						7)	wsTopHosts=35;break;;
						8)	wsTopHosts=40;break;;
					 [Ee])	c_stats;break;;
						*)	printf "\\n input is not an option\\n";;
					esac
				done;write_conf_file
				print_red_line
				printf " Select the value of top 'x'${GREEN} clients${NC} the stats\\n"
				printf " should compile,${GREEN} currently set to: $wsTopClients${NC}\\n\\n"
				printf " 1.  5\\n 2. 10 (default)\\n 3. 15\\n 4. 20\\n 5. 25\\n 6. 30\\n 7. 35\\n 8. 40\\n"
				while true; do
					printf "\\n Set top 'x'${GREEN} clients${NC} count [1-8 e=Exit] ";read -r topclient
					case "$topclient" in
						1)	wsTopClients=5;break;;
						2)	wsTopClients=10;break;;
						3)	wsTopClients=15;break;;
						4)	wsTopClients=20;break;;
						5)	wsTopClients=25;break;;
						6)	wsTopClients=30;break;;
						7)	wsTopClients=35;break;;
						8)	wsTopClients=40;break;;
					 [Ee])	c_stats;break;;
						*)	printf "\\n input is not an option\\n";;
					esac
				done;write_conf_file
				lastAction=" value of stats top X set to $wsTopHosts/$wsTopClients"
				c_stats;break;;
			4)	if [ -z "$weeklyStats" ]; then
					lastError=" Weekly stats are disabled, enable it first."
					reload_menu
				fi
				print_red_line
				printf " Filters local client names  ${GREEN}$wsFilterLN${NC}\\n\\n"
				printf " Removes local client name queries for more\\n accurate router stats results.\\n"
				printf " Note: To test if this affects the accuracy, run\\n current stats with setting to off, then\\n"
				printf " set to on and run stats again. Compare results.\\n\\n"
				printf " 1. on\\n 2. off\\n"
				while true; do
					printf "\\n Select filter option [1-2 e=Exit] ";read -r filterhosts
					case "$filterhosts" in
						1)	wsFilterLN=on;break;;
						2)	wsFilterLN=off;break;;
					 [Ee])	c_stats;break;;
						*)	printf "\\n input is not an option\\n";;
					esac
				done;write_conf_file
				lastAction=" filter local client names set to $wsFilterLN"
				c_stats;break;;
			5)	print_red_line
				[ -f "${DIVERSION_DIR}/backup/diversion_stats-iphostleases" ] && touch /tmp/divstats-iphostleases.txt
				if [ -s /tmp/etc/hosts.dnsmasq ]; then
					printf " Local clients as they appear in the router stats.\\n Note: For (Name-N/A) no name is available.\\n"
					printf "\\n Resolving is done with these files,\\n${GREEN} hosts.dnsmasq${NC} has precedence:\\n"
					printf " - /tmp/etc/hosts.dnsmasq\\n - /var/lib/misc/dnsmasq.leases\\n"
					printf "\\n${GREEN} clients in hosts.dnsmasq:${NC}\\n"
					cat /tmp/etc/hosts.dnsmasq | sort -t . -k 4,4n -u | sed -e 's/^/ /'
					[ -f /tmp/divstats-iphostleases.txt ] && cat /tmp/etc/hosts.dnsmasq >>/tmp/divstats-iphostleases.txt
				fi
				if [ -s /var/lib/misc/dnsmasq.leases ]; then
					printf "\\n${GREEN} clients in dnsmasq.leases:${NC}\\n"
					rm -f /tmp/divstats-iphostleases
					for i in $(awk '{print $3}' /var/lib/misc/dnsmasq.leases); do
						if grep -wq $i /var/lib/misc/dnsmasq.leases; then
							if grep -wq "$i *" /var/lib/misc/dnsmasq.leases; then
								echo " $i (Name-N/A)" >>/tmp/divstats-iphostleases
							else
								echo " $(awk -v var="$i" -F' ' '$3 == var{print $3, $4}' /var/lib/misc/dnsmasq.leases)" >>/tmp/divstats-iphostleases
							fi
						fi
					done
					cat /tmp/divstats-iphostleases | sort -t . -k 4,4n -u
					[ -f /tmp/divstats-iphostleases.txt ] && cat /tmp/divstats-iphostleases >>/tmp/divstats-iphostleases.txt
				else
					printf " (dnsmasq.leases file is empty)\\n"
				fi
				if [ -s /tmp/divstats-iphostleases.txt ]; then
					cat /tmp/divstats-iphostleases.txt "${DIVERSION_DIR}/backup/diversion_stats-iphostleases" >/tmp/divstats-iphostleases.tmp
					sed -i '/^\s*$/d;/Name-N/d;s/^[ \t]*//' /tmp/divstats-iphostleases.tmp
					cat /tmp/divstats-iphostleases.tmp | sort -t . -k 4,4n -u > "${DIVERSION_DIR}/backup/diversion_stats-iphostleases"
					printf "\\n${INFO} $NAME stats client name backup file updated\\n"
				fi
				rm -f /tmp/divstats-iphostleases*
				press_enter_to "return to stats settings"
				c_stats;break;;
			6)	print_red_line

				add_exclusion_IP(){

					printf " Enter $1 Address [e=Exit] ";read -r setIP

					if [ "$setIP" = "e" ]; then
						c_stats
					fi

					if [ "$excludeIPlist" ] && echo "$excludeIPlist" | grep -q "$setIP"; then
						printf "\\n${NOK} $setIP is already excluded\\n\\n"
						add_exclusion_IP "$1"
						return 1
					fi

					dhcp_staticlist=$(nvram get dhcp_staticlist)
					lan_ipaddr=$(nvram get lan_ipaddr)
					if [ "$psIP" ]; then
						otherIP=$psIP
						otherSV="pixelserv-tls IP"
					fi

					if [ "$setIP" = "$lan_ipaddr" ]; then
						printf "\\n${NOK} $setIP is this routers address\\n\\n"
						add_exclusion_IP "$1"
						return 1
					fi

					if ! expr "$setIP" : '[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*$' >/dev/null; then
						printf "\\n${NOK} $setIP is not a valid IP address\\n\\n"
						add_exclusion_IP "$1"
						return 1
					fi
					if [ "$(printf "$lan_ipaddr" | sed 's/\.[0-9]*$/./')" = "$(printf "$setIP" | sed 's/\.[0-9]*$/./')" ]; then
						if [ "$otherIP" ] && [ "$otherIP" = "$setIP" ]; then
							printf "\\n${NOK} $setIP is set as $otherSV address\\n\\n"
							add_exclusion_IP "$1"
							return 1
						fi

						if echo "$dhcp_staticlist" | grep -q "$setIP"; then
							printf "\\n${OK} $setIP is a manually assigned IP\\n"
						else
							printf "\\n${NOK} $setIP is not a manually assigned IP\\n\\n"
							add_exclusion_IP "$1"
							return 1
						fi

					else
						printf "\\n${NOK} $setIP is not a router address\\n\\n"
						add_exclusion_IP "$1"
						return 1
					fi

					printf "${OK} $1 address set to $setIP\\n"
				}

				printf "${INFO} Exclude IP adresses in stats\\n\\n"
				printf " To exclude an IP, it must be in the\\n Manually Assigned IP list in LAN / DHCP Server.\\n\\n"
				printf "${ATTN} This permanently removes affected entries in\\n${SPACE} the Dnsmasq log during the stats generation!\\n\\n"
				exopt2=;exopt3=
				if [ -z "$excludeIP" ]; then
					printf " 1. Add IP exclusion\\n"
					exopt=1
				else
					printf " Excluded IP adress(es):\\n ${exoptColor}$excludeIPlist${NC}\\n\\n"
					printf " 1. Add additional IP exclusion\\n"
					printf " 2. Remove IP exclusion\\n"
					if [ "$excludeIP" = on ]; then
						printf " 3. ${RED}Disable${NC} IP exclusion in stats\\n"
					else
						printf " 3. ${GREEN}Enable${NC} IP exclusion in stats\\n"
					fi
					exopt=3;exopt2=2;exopt3=3

				fi

				while true; do
					printf "\\n Enter option [1-$exopt e=Exit] ";read -r selection
					case "$selection" in
						1)			print_red_line
									add_exclusion_IP "exclusion IP"
									[ -z "$excludeIP" ] && excludeIP=on
									if [ -z "$excludeIPlist" ]; then
										excludeIPlist="$setIP "
									else
										excludeIPlist="$excludeIPlist$setIP "
									fi
									break;;
						[$exopt2])	print_red_line
									i=1;noad=
									for address in $excludeIPlist; do
											echo " ${i}. ${exoptColor}$address${NC}"
											eval IP$i="$address"
											noad="${noad}${i} "
											i=$((i+1))
									done
									[ "$i" = "1" ] && IPNo=1-1 || IPNo="1-$((i-1))"
									while true; do
										printf "\\n Select IP to remove [$IPNo e=Exit] ";read -r selection
										case "$selection" in
											e)			c_stats;break;;
											[$noad])	eval iptd="\$IP$selection"
														excludeIPlist="$(echo "$excludeIPlist" | sed "s/$iptd //")"
														if [ "$excludeIPlist" = "" ]; then
															excludeIP=
														fi
														break;;
											*)			printf "\\n input is not an option\\n";;
										esac
									done
									break;;
						[$exopt3])	if [ "$excludeIP" = on ]; then
										excludeIP=off
									else
										excludeIP=on
									fi;break;;
						[Ee])		c_stats;break;;
						*)			printf "\\n input is not an option\\n";;
					esac
				done;write_conf_file
				lastAction=" edited IP exclusion list"
				c_stats;break;;
		 [Ee])	reload_menu;break;;
			*)	printf "\\n input is not an option\\n";;
		esac
	done
}

on_off_weekly_stats(){
	if [ "$logging" = "off" ]; then
		lastError=" logging is disabled, enable it first."
		reload_menu
	fi

	set_weekly_stats(){
		printf " Select how to output the weekly stats:\\n\\n"
		printf " 1. Save to file in /stats/\\n"
		printf " 2. As email, stats in body\\n"
		printf " 3. As email, stats in body & save to file\\n"
		printf " 4. As email, stats as attachment\\n"
		printf " 5. As email, stats as attachment & save to file\\n"
		printf "\\n Note: The stats compiling log file can be\\n viewed in ${RED_BG} sf ${NC} (stats.div.log)\\n"
		while true; do
			printf "\\n Select output [1-5 e=Exit] ";read -r continue
			case "$continue" in
				1)	wsTo=file;wsAs=body;wsDo=save;break;;
				2)	check_email_conf_file
					wsTo=email;wsAs=body;wsDo=delete;break;;
				3)	check_email_conf_file
					wsTo=email;wsAs=body;wsDo=save;break;;
				4)	check_email_conf_file
					wsTo=email;wsAs=attachment;wsDo=delete;break;;
				5)	check_email_conf_file
					wsTo=email;wsAs=attachment;wsDo=save;break;;
			 [Ee])	c_stats;break;;
				*)	printf "\\n input is not an option\\n";;
			esac
		done
		get_file stats.div check
		weeklyStats=on
		write_conf_file
		restart_DNSMASQ
		lastAction=" Weekly stats enabled.\\n Stats will be compiled each $(echo $bfUpdateDay | sed 's/,.*//') @ $((bfUpdateHour-1)):30"
	}

	if [ "$weeklyStats" = "on" ]; then
		print_red_line
		printf " Weekly stats settings\\n\\n"
		printf " 1. ${RED}Disable${NC} weekly stats\\n 2. Change settings\\n"
		while true; do
			printf "\\n Enter selection [1-2 e=Exit] ";read -r confirm
			case "$confirm" in
				1)	weeklyStats=off
					write_conf_file
					restart_DNSMASQ
					lastAction=" weekly stats disabled";break;;
				2)	print_red_line
					set_weekly_stats;break;;
			 [Ee])	c_stats;break;;
				*)	printf "\\n input is not an option\\n";;
			esac
		done
	elif [ -z "$weeklyStats" ]; then
		print_red_line
		printf " This enables the weekly stats report.\\n"
		printf " Stats will be compiled weekly, half an hour\\n"
		printf " before the blocking list update ($(echo $bfUpdateDay | sed 's/,.*//') @ $((bfUpdateHour-1)):30).\\n"
		echo
		set_weekly_stats
	elif [ "$weeklyStats" = "off" ]; then
		weeklyStats=on
		write_conf_file
		restart_DNSMASQ
		lastAction=" Weekly stats re-enabled.\\n Stats will be compiled each $(echo $bfUpdateDay | sed 's/,.*//') @ $((bfUpdateHour-1)):30"
	fi
}

run_current_stats(){
	if [ "$logging" = "off" ]; then
		lastError=" logging is disabled, enable it first."
		reload_menu
	fi
	printf " This compiles a current stats report.\\n\\n"
	printf " Select how to output the current stats report:\\n\\n"
	printf " 1. Save to file in /stats/\\n"
	printf " 2. As email, stats in body\\n"
	printf " 3. As email, stats in body & save to file\\n"
	printf " 4. As email, stats as attachment\\n"
	printf " 5. As email, stats as attachment & save to file\\n"
	while true; do
		printf "\\n Select output [1-5 e=Exit] ";read -r continue
		case "$continue" in
			1)	currentParams="file body save"
				break;;
			2)	check_email_conf_file
				currentParams="email body delete"
				break;;
			3)	check_email_conf_file
				currentParams="email body save"
				break;;
			4)	check_email_conf_file
				currentParams="email attachment delete"
				break;;
			5)	check_email_conf_file
				currentParams="email attachment save"
				break;;
		 [Ee])	c_stats;break;;
			*)	printf "\\n input is not an option\\n";;
		esac
	done
	get_file stats.div check
	sh /opt/share/diversion/file/stats.div $currentParams >/dev/null 2>&1 &
	lastAction=" The current stats are being compiled now.\\n This will take some time. If compiling fails,"
	lastAction="$lastAction\\n check the stats.div.log in${NC} ${RED_BG} sf ${NC}"
}

c_email_edit(){
	notice_email_settings(){
		echo " If you have Two Factor Authentication (2FA)"
		echo " enabled, use an App password, or get a new email"
		echo " address without 2FA (not recommended)."
		echo
		echo " Common SMTP Server settings"
		echo " Provider    Server                 Port Protocol"
		echo " ------------------------------------------------"
		echo " Gmail       smtp.gmail.com         465  smtps"
		echo " mail.com    smtp.mail.com          587  smtp"
		echo " Yahoo!      smtp.mail.yahoo.com    465  smtps"
		echo " outlook.com smtp-mail.outlook.com  587  smtp"
	}
	writePW=
	if [ ! -f "${DIVERSION_DIR}/.conf/email.conf" ]; then
		print_red_line
		echo "${ATTN} You need to first set your email settings"
		echo
		echo " Example settings:"
		echo "${RED_BG} From address    ${NC} e.g. \"john.doe@gmail.com\""
		echo "${RED_BG} To name         ${NC} e.g. \"John Doe\""
		echo "${RED_BG} To address (1)  ${NC} e.g. \"kate.austen@lost.com\""
		echo "${RED_BG} Router name (2) ${NC} e.g. \"Fishing-Cabin\""
		echo "${RED_BG} User name       ${NC} e.g. \"john.doe@gmail.com\""
		echo "${RED_BG} Password (3)    ${NC} e.g. \"Sup3rPa##w0rd\""
		echo "${RED_BG} SMTP Server     ${NC} e.g. \"smtp.gmail.com\""
		echo "${RED_BG} Server port     ${NC} e.g. \"465\""
		echo "${RED_BG} Protocol (4)    ${NC} e.g. \"smtps\""
		echo "${RED_BG} SSL flag (5)    ${NC} e.g. \"--insecure\""
		echo
		echo " (1) To address can be your email or another"
		echo "     email address."
		echo " (2) This friendly router name may only consist"
		echo "     of alphanumeric, - and _ characters. No spaces"
		echo "     and not more than 16 characters. The word"
		echo "     \"Router\" is auto-added after the name."
		echo " (3) Password may NOT contain \" character."
		echo " (4) smtps works for most, outlook.com may need smtp."
		echo " (5) some servers may require the --insecure flag."
		echo
		notice_email_settings
		print_red_line
		echo " You are about to enter your email credentials."
		echo " If you make a mistake, fill in all fields anyway."
		echo
		echo " The Edit function is available afterwards."
		echo " Caution: Password is in clear text."
		echo
		continue_dialog
		printf "\\n${RED_BG} Enter From address: ${NC} ";read -r FROM_ADDRESS
		printf "\\n${RED_BG} Enter To name: ${NC} ";read -r TO_NAME
		printf "\\n${RED_BG} Enter To address: ${NC} ";read -r TO_ADDRESS
		printf "\\n${RED_BG} Enter friendly router name: ${NC} ";read -r FRIENDLY_ROUTER_NAME
		printf "\\n${RED_BG} Enter User name: ${NC} ";read -r USERNAME
		printf "\\n${RED_BG} Enter Password: ${NC} ";read -r PASSWORD
		writePW=1
		printf "\\n${RED_BG} Enter SMTP Server: ${NC} ";read -r SMTP
		printf "\\n${RED_BG} Enter Server port: ${NC} ";read -r PORT
		printf "\\n${RED_BG} Enter Protocol: ${NC} ";read -r PROTOCOL
		printf "\\n${RED_BG} Enter SSL flag: ${NC} ";read -r SSL_FLAG
		write_email_config_file
		check_friendly_name
		c_email_edit
	else
		. "${DIVERSION_DIR}/.conf/email.conf"
		print_red_line
		echo " Your email credentials are saved in:"
		echo " ${DIVERSION_DIR}/.conf/email.conf"
		echo
		notice_email_settings
		echo
		echo "  1. Edit From address:   ${GREEN}$FROM_ADDRESS${NC}"
		echo "  2. Edit To name:        ${GREEN}$TO_NAME${NC}"
		echo "  3. Edit To address:     ${GREEN}$TO_ADDRESS${NC}"
		echo "  4. Edit Router name:    ${GREEN}$FRIENDLY_ROUTER_NAME${NC}"
		echo "  5. Edit User name:      ${GREEN}$USERNAME${NC}"
		echo "  6. Edit Password:       select Edit to view"
		echo "  7. Edit SMTP Server:    ${GREEN}$SMTP${NC}"
		echo "  8. Edit Server port:    ${GREEN}$PORT${NC}"
		echo "  9. Edit Protocol:       ${GREEN}$PROTOCOL${NC}"
		if [ "$SSL_FLAG" ]; then
			echo " 10. Edit SSL flag:       ${GREEN}$SSL_FLAG${NC}"
		else
			echo " 10. Edit SSL flag:       ${GRAY}Set to${NC} ${GREEN}--insecure${NC} ${GRAY}if curl problems occur${NC}"
		fi
		echo " 11. Send testmail to confirm settings"

		if [ -f "${DIVERSION_DIR}/.conf/email.conf" ] && grep -q 'PUT YOUR PASSWORD HERE' "${DIVERSION_DIR}/.conf/email.conf"; then
			printf "\\n${INFO} Set your email password, it has been redacted\\n$SPACE for security reasons.\\n"
		fi

		while true; do
			printf "\\n Enter your selection [1-11 e=Exit] ";read -r continue
			case "$continue" in
				1)	printf "\\n${RED_BG} Enter From address: ${NC} [e=Exit] ";read -r value
					FROM_ADDRESS=$value;break;;
				2)	printf "\\n${RED_BG} Enter To name: ${NC} [e=Exit] ";read -r value
					TO_NAME=$value;break;;
				3)	printf "\\n${RED_BG} Enter To address: ${NC} [e=Exit] ";read -r value
					TO_ADDRESS=$value;break;;
				4)	printf "\\n This friendly router name may only consist of\\n alphanumeric, - and _ characters. No spaces and\\n"
					printf " not more than 16 characters.\\n The word \"Router\" is auto-added after the name.\\n"
					printf "\\n${RED_BG} Enter Router name: ${NC} [e=Exit] ";read -r value
					case "$value" in
					 [Ee])	c_email_edit;;
						*)	;;
					esac
					FRIENDLY_ROUTER_NAME=$value
					check_friendly_name;break;;
				5)	printf "\\n${RED_BG} Enter User name: ${NC} [e=Exit] ";read -r value
					USERNAME=$value;break;;
				6)	print_red_line
					echo " $(/usr/sbin/openssl aes-256-cbc -d -in "${DIVERSION_DIR}/.conf/emailpw.enc" -pass pass:ditbabot,isoi) ${RED}<-- current password${NC}"
					while true; do
						printf "\\n Edit password now? [1=Yes e=Exit] ";read -r continue
						case "$continue" in
							1)		printf "\\n${RED_BG} Enter new Password: ${NC} [e=Exit] ";read -r value
									if [ "$value" != e ]; then
										writePW=1
										PASSWORD=$value
									fi
									break;;
							[Ee])	c_email_edit;break;;
							*)		printf "\\n input is not an option\\n";;
						esac
					done
					break;;
				7)	printf "\\n${RED_BG} Enter SMTP Server: ${NC} [e=Exit] ";read -r value
					SMTP=$value;break;;
				8)	printf "\\n${RED_BG} Enter Server port: ${NC} [e=Exit] ";read -r value
					PORT=$value;break;;
				9)	printf "\\n${RED_BG} Enter Protocol: ${NC} [e=Exit] ";read -r value
					PROTOCOL=$value;break;;
				10)	printf "\\n${RED_BG} Enter SSL flag: ${NC} [e=Exit] ";read -r value
					SSL_FLAG=$value;break;;
				11)	print_red_line
					printf " This will send a testmail from:\\n\\n $FROM_ADDRESS to:\\n $TO_NAME <$TO_ADDRESS>\\n"
					while true; do
						printf "\\n Continue? [1=Yes e=Exit] ";read -r continue
						case "$continue" in
							1)	check_email_conf_file
								. "${DIVERSION_DIR}/.conf/email.conf"
								rm -f /tmp/divmail-body
								echo
								echo "Subject: Router testmail $(date +"%a %b %d %Y")" >/tmp/divmail-body
								echo "From: \"$NAME\" <$FROM_ADDRESS>" >>/tmp/divmail-body
								echo "Date: $(date -R)" >>/tmp/divmail-body
								echo "To: \"$TO_NAME\" <$TO_ADDRESS>" >>/tmp/divmail-body
								echo >>/tmp/divmail-body
								echo " Greetings from $NAME $VERSION" >>/tmp/divmail-body
								echo >>/tmp/divmail-body
								echo " This is a testmail." >>/tmp/divmail-body
								echo >>/tmp/divmail-body
								echo " Very truly yours," >>/tmp/divmail-body
								echo " Your $FRIENDLY_ROUTER_NAME router (Model type $routerModel)" >>/tmp/divmail-body
								echo >>/tmp/divmail-body

								/usr/sbin/curl --url $PROTOCOL://$SMTP:$PORT \
									--mail-from "$FROM_ADDRESS" --mail-rcpt "$TO_ADDRESS" \
									--upload-file /tmp/divmail-body \
									--ssl-reqd \
									--user "$USERNAME:$(/usr/sbin/openssl aes-256-cbc -d -in "${DIVERSION_DIR}/.conf/emailpw.enc" -pass pass:ditbabot,isoi)" $SSL_FLAG

								if [ "$?" = "0" ]; then
									lastAction=" testmail sent to $TO_NAME\\n at $TO_ADDRESS"
									logger -t Diversion "sent a testmail (user action)"
								else
									printf "\\n${NOK} sending testmail failed\\n\\n"
									printf " Note the curl: error above and check your settings\\n"
									logger -t Diversion "sending of a testmail failed (user action)"
									press_enter_to "return to menu"
									rm -f /tmp/divmail*
									c_email_edit
								fi
								rm -f /tmp/divmail*
								echo
								sleep 2;reload_menu;break;;
						 [Ee])	c_email_edit;break;;
							*)	printf "\\n input is not an option\\n";;
						esac
					done;break;;
			 [Ee])  lastAction=" edit email config";reload_menu;break;;
				*)	printf "\\n input is not an option\\n";;
			esac
		done

		case "$value" in
		 [Ee])	c_email_edit;break;;
			*)	write_email_config_file;c_email_edit;break;;
		esac
	fi
}

check_friendly_name(){
	check_subroutine(){
		printf "\\n${RED_BG} Enter Router name: ${NC} [e=Exit] ";read -r value
		case "$value" in
		 [Ee])	c_email_edit;;
			*)	;;
		esac
		FRIENDLY_ROUTER_NAME=$value
		check_friendly_name
	}

	if [ "${#FRIENDLY_ROUTER_NAME}" -lt "2" ] || [ "${#FRIENDLY_ROUTER_NAME}" -gt "16" ]; then
		echo
		echo "${RED} Router name length under or over 2 to 16 characters${NC}"
		check_subroutine
	fi
	case "$FRIENDLY_ROUTER_NAME" in
				   -*|_* )	echo
							echo "${RED} Router name name not OK, starts with hyphen or underscore${NC}"
							check_subroutine;;
				   *-|*_ )	echo
							echo "${RED} Router name name not OK, ends with hyphen or underscore${NC}"
							check_subroutine;;
		*[^a-zA-Z0-9-_]* )	echo
							echo "${RED} Router name name not OK, special characters are not allowed${NC}"
							check_subroutine;;
	esac
	write_email_config_file
	c_email_edit
}

write_email_config_file(){
	[ "$writePW" = 1 ] && echo -n $PASSWORD | /usr/sbin/openssl aes-256-cbc -out "${DIVERSION_DIR}/.conf/emailpw.enc" -pass pass:ditbabot,isoi
	writePW=
	echo "# Email settings (mail envelope) #" > "${DIVERSION_DIR}/.conf/email.conf"
	echo "FROM_ADDRESS=\"$FROM_ADDRESS\"" >> "${DIVERSION_DIR}/.conf/email.conf"
	echo "TO_NAME=\"$TO_NAME\"" >> "${DIVERSION_DIR}/.conf/email.conf"
	echo "TO_ADDRESS=\"$TO_ADDRESS\"" >> "${DIVERSION_DIR}/.conf/email.conf"
	echo "FRIENDLY_ROUTER_NAME=\"$FRIENDLY_ROUTER_NAME\"" >> "${DIVERSION_DIR}/.conf/email.conf"
	echo >> "${DIVERSION_DIR}/.conf/email.conf"
	echo "# Email credentials #" >> "${DIVERSION_DIR}/.conf/email.conf"
	echo "USERNAME=\"$USERNAME\"" >> "${DIVERSION_DIR}/.conf/email.conf"
	echo "# Encrypted Password is stored in emailpw.enc file." >> "${DIVERSION_DIR}/.conf/email.conf"
	echo >> "${DIVERSION_DIR}/.conf/email.conf"
	echo "# Server settings #" >> "${DIVERSION_DIR}/.conf/email.conf"
	echo "SMTP=\"$SMTP\"" >> "${DIVERSION_DIR}/.conf/email.conf"
	echo "PORT=\"$PORT\"" >> "${DIVERSION_DIR}/.conf/email.conf"
	echo "PROTOCOL=\"$PROTOCOL\"" >> "${DIVERSION_DIR}/.conf/email.conf"
	echo "SSL_FLAG=\"$SSL_FLAG\"" >> "${DIVERSION_DIR}/.conf/email.conf"
}

check_email_conf_file(){
	if [ ! -f "${DIVERSION_DIR}/.conf/email.conf" ]; then
		c_email_edit
	else
		FROM_ADDRESS=;TO_NAME=;TO_ADDRESS=;USERNAME=;PASSWORD=;SMTP=;PORT=;PROTOCOL=
		. "${DIVERSION_DIR}/.conf/email.conf"
		if [ -z "$FROM_ADDRESS" ] || [ -z "$TO_NAME" ] || [ -z "$TO_ADDRESS" ] || [ -z "$USERNAME" ] || \
		[ -z "$USERNAME" ] || [ ! -f "${DIVERSION_DIR}/.conf/emailpw.enc" ] || [ -z "$SMTP" ] || [ -z "$PORT" ] || [ -z "$PROTOCOL" ]; then
			printf "\\n${NOK} email settings not set or incomplete.\\n\\n"
			continue_dialog;c_email_edit
		elif [ "$PASSWORD" = "PUT YOUR PASSWORD HERE" ]; then
			printf "\\n${NOK} email password has not been set.\\n\\n"
			continue_dialog;c_email_edit
		fi
	fi
}

c_fw_update(){
	print_red_line
	echo " Firmware update notification info:"
	echo
	echo " Receive email notification for newer"
	echo " Asuswrt-Merlin firmware availability for this"
	echo " router within about 48 hours of release."
	echo
	if [ "$fwUpdate" = "on" ]; then
		echo " 1. ${RED}Disable${NC} firmware notification"
		echo " 2. Send a test notification email"
		funo="2"
	else
		echo " 1. ${GREEN}Enable${NC} firmware notification"
		funo="1"
	fi

	while true; do
		printf "\\n Enter selection [1-$funo e=Exit] ";read -r confirm
		case "$confirm" in
			1)	read_conf_file
				echo
				if [ -z "$fwUpdate" ]; then
					version_check(){ echo "$@" | awk -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }';}
					if [ "$(version_check $(nvram get buildno))" -ge "$(version_check 380.65)" ]; then
						if [ "$(nvram get firmware_server)" = "https://fwupdate.lostrealm.ca/asuswrt-merlin" ] || [ "$(nvram get firmware_server)" = "https://fwupdate.asuswrt-merlin.net" ]; then
							if [ "$(nvram get firmware_check_enable)" = "1" ]; then
								if [ -f "/jffs/scripts/update-notification" ]; then
									if grep -wq '^#bof' /jffs/scripts/update-notification && grep -wq '^#eof' /jffs/scripts/update-notification; then
										check_email_conf_file
										get_file update-notification new "${DIVERSION_DIR}/file" /file/ /jffs/scripts/
										set_file_permissions
										fwUpdate=on
										write_conf_file
										lastAction=" Enabled new firmware notification"
										c_fw_update
									else
										printf " Found a custom notification script at:\\n ${GREEN}/jffs/scripts/update-notification${NC}\\n"
										printf " This needs to be removed first.\\n"
										while true; do
											printf "\\n Remove the file? [1=Yes 2=No] ";read -r confirm
											case "$confirm" in
												1)	rm -f /jffs/scripts/update-notification
													check_email_conf_file
													get_file update-notification new "${DIVERSION_DIR}/file" /file/ /jffs/scripts/
													set_file_permissions
													fwUpdate=on
													write_conf_file
													lastAction=" Enabled new firmware notification"
													c_fw_update
													break;;
												2)	exit_message;break;;
												*)	printf "\\n input is not an option\\n";;
											esac
										done
									fi
								else
									check_email_conf_file
									get_file update-notification new "${DIVERSION_DIR}/file" /file/ /jffs/scripts/
									set_file_permissions
									fwUpdate=on
									write_conf_file
									lastAction=" Enabled new firmware notification"
									c_fw_update
								fi
							else
								echo " New firmware version check is not enabled,"
								echo " you must enable it first:"
								echo
								echo " In the router Web UI, go to Administration / Firmware Upgrade"
								echo " and set 'Scheduled check for new firmware availability' to 'Yes'"
								echo
								echo " Or for older firmware versions:"
								echo " In the router Web UI, go to Tools / Other Settings"
								echo " and set 'New firmware version check' to 'Yes'"
								echo " then click 'Apply'"
								press_enter_to acknowledge
								reload_menu
							fi
						else
							echo " Your firmware does not support Asuswrt-Merlin"
							echo " update notification"
							press_enter_to acknowledge
							reload_menu
						fi
					else
						echo " Your firmware ($(nvram get buildno)) does not support"
						echo " update notification. This feature was introduced"
						echo " in Asuswrt-Merlin 380.65."
						press_enter_to acknowledge
						reload_menu
					fi
				elif [ "$fwUpdate" = "on" ]; then
					print_red_line
					echo " Firmware notification is enabled at the moment."
					while true; do
						printf "\\n Disable it? [1=Yes e=Exit] ";read -r confirm
						case "$confirm" in
							1)	rm -f /jffs/scripts/update-notification
								rm -f "${DIVERSION_DIR}/file/update-notification"
								fwUpdate=
								write_conf_file
								lastAction=" Firmware notification disabled"
								reload_menu;break;;
						 [Ee])	exit_message;break;;
							*)	printf "\\n input is not an option\\n";;
						esac
					done
				fi;break;;
			2)	if [ "$fwUpdate" = "on" ]; then
					check_email_conf_file
					echo "${GRAY}"
					sh /jffs/scripts/update-notification test
					if [ "$?" = "0" ]; then
						echo "${NC}"
						. "${DIVERSION_DIR}/.conf/email.conf"
						lastAction=" Firmware notification test email sent\\n to $TO_NAME at $TO_ADDRESS"
						reload_menu
					else
						echo "${NC}"
						echo "${NOK} sending test notification failed"
						echo
						echo " Note the curl: error above and check your settings"
						echo
						press_enter_to "return to menu"
						c_fw_update
					fi
				else
					lastError=" Firmware notification is not enabled"
					reload_menu
				fi;break;;
		 [Ee])	break;;
			*)	printf "\\n input is not an option\\n";;
		esac
	done
}

d_reset(){
	if [ "$logging" = "off" ]; then
		lastError=" logging is disabled, enable it first."
		reload_menu
	fi
	if [ "$adsBlocked" = "0" ]; then
		adsc="(ads counter is at 0)"
	else
		adsc="${GREEN_BG} $adsBlockedHuman ${NC} ${GREEN_BG} $adsWeekHuman ${NC} ${GREEN_BG} $adsNewHuman ${NC}"
	fi
	reset_logfiles(){
		if [ -f "/opt/var/log/dnsmasq.log" ]; then
			rm -f /opt/var/log/dnsmasq.log*
			touch /opt/var/log/dnsmasq.log /opt/var/log/dnsmasq.log1 /opt/var/log/dnsmasq.log2
			if [ "$bfFs" = "on" ] && [ "$alternateBF" = "on" ]; then
				touch /opt/var/log/dnsmasq.log3 /opt/var/log/dnsmasq.log4 /opt/var/log/dnsmasq.log5
			fi
			chown nobody /opt/var/log/dnsmasq.log*
			chmod 0640 /opt/var/log/dnsmasq.log*
			kill -USR2 $(pidof dnsmasq)
			logger -t Diversion "reset dnsmasq log files (user action), from Diversion menu"
		fi
	}
	read_conf_file
	echo " This resets ads counters and Dnsmasq log files."
	echo
	echo " 1. Reset ads counters to 0  $adsc"
	echo " 2. Reset Dnsmasq log files"
	echo " 3. Reset both"
	while true; do
		printf "\\n Enter selection [1-3 e=Exit] ";read -r continue
		case "$continue" in
			1)	adsBlocked=0;adsWeek=0;adsNew=0
				[ "$alternateBF" ] && adsBlockedAlt=0;adsWeekAlt=0;adsNewAlt=0
				adsLastCount=$(date +"%b %d %R")
				write_conf_file
				lastAction=" Ads counters reset"
				reload_menu;break;;
			2)	reset_logfiles
				lastAction=" Dnsmasq log files reset"
				reload_menu;break;;
			3)	adsBlocked=0;adsWeek=0;adsNew=0
				[ "$alternateBF" ] && adsBlockedAlt=0;adsWeekAlt=0;adsNewAlt=0
				adsLastCount=$(date +"%b %d %R")
				write_conf_file
				reset_logfiles
				lastAction=" Ads counter and log files reset"
				reload_menu;break;;
		 [Ee])  exit_message;reload_menu;break;;
			*) 	printf "\\n input is not an option\\n";;
		esac
	done
}

ep_function(){
	if [ "$EN" = "1" ]; then
		min=6 max=6
	elif [ "$EN" -ge "2" ]; then
		min=1 max=6
		if [ "$LANblockingIP" ] && [ "$LANblockingIP" = "on" ]; then
			min=6 max=6
		fi
	fi

	printf " This manages installed Entware packages.\\n\\n"
	if [ "$EN" -ge "2" ]; then
		if [ "$LANblockingIP" ] && [ "$LANblockingIP" = "off" ] || [ -z "$LANblockingIP" ]; then
			printf " To check the pixelserv-tls stats, enter\\n"
			printf " ${GREEN}$psIP/servstats${NC} into your browser.\\n"
			printf "\\n To import the pixelserv-tls certificate\\n into browser and devices, open\\n ${GREEN}$psIP/ca.crt${NC} in a browser.\\n"
			echo
		fi
	fi
	printf " ${GREEN}$entVersion${NC} is installed at\\n ${GREEN}${entPath#/tmp}${NC}, mounted as ${GREEN}/opt${NC} ($(du -hs /opt/ | awk '{print $1}'))\\n\\n"

	if [ "$EN" -ge "2" ]; then
		if [ "$LANblockingIP" ] && [ "$LANblockingIP" = "off" ] || [ -z "$LANblockingIP" ]; then
			if [ "$psState" = "on" ]; then
				printf "${GRAY1} 1. ${RED}Disable${NC} pixelserv-tls\\n"
			else
				printf " 1. ${GREEN}Enable${NC} pixelserv-tls\\n"
			fi
			printf " 2. Add or remove pixelserv-tls switches\\n"
			printf " 3. Manage pixelserv-tls certificates\\n"
			printf " 4. Restart pixelserv-tls${NC1}\\n"
		fi
	fi

	if [ "$EN" -ge "2" ]; then
		if [ "$LANblockingIP" ] && [ "$LANblockingIP" = "off" ] || [ -z "$LANblockingIP" ]; then
			printf " 5. Change pixelserv-tls IP address\\n"
		fi
	fi
	printf " 6. Manage Entware packages\\n"

	while true; do
		entloop(){
			printf "\\n Enter selection [$min-$max e=Exit] ";read -r continue
			if [ "$continue" -eq "$continue" 2>/dev/null ]; then
				if [ "$continue" -lt "$min" ] || [ "$continue" -gt "$max" ]; then
					printf "\\n input is not an option\\n"
					entloop;return 1
				fi
			fi
			case "$continue" in
				1)	if [ "$adblocking" = "off" ]; then
						lastError=" ad-blocking is disabled. Enable it first."
						reload_menu
					fi
					if [ "$psState" = "on" ]; then
						blockingIP=0.0.0.0
						on_off_pixelserv off
						prevPsState=off
						write_conf_file
						restart_DNSMASQ
						lastAction=" pixelserv-tls disabled"
					elif [ "$psState" = "off" ] || [ -z "$psState" ]; then
						blockingIP=$psIP
						psState=on
						prevPsState=on
						write_conf_file
						on_off_pixelserv on
						restart_DNSMASQ
						lastAction=" pixelserv-tls enabled on IP $psIP"
					fi
					break;;
				2)	if [ "$psState" = "off" ]; then
						lastError=" pixelserv-tls is inactive. Enable it first."
						reload_menu
					fi
					print_red_line
					printf " This adds switches to pixelserv-tls.\\n${RED} Be careful, there's no input validation for\\n"
					printf " additional parameters.${NC}\\n"
					add_switches
					break;;
				3)	purge_ps_certs(){
						echo
						echo "${INFO} Purging pixelserv-tls domain certificates"
						mv /opt/var/cache/pixelserv/ca.* /opt/var/cache
						rm -rf /opt/var/cache/pixelserv/*
						mv /opt/var/cache/ca.* /opt/var/cache/pixelserv
						on_off_pixelserv on restart
					}

					print_red_line

					unset "CAexpiry" "dcrt" "dcrtexpiry" "CAkeyLength" "dcrtkeyLength"
					if [ -f /opt/var/cache/pixelserv/ca.crt ]; then
						CAexpiry=$(/usr/sbin/openssl x509 -text -noout -in /opt/var/cache/pixelserv/ca.crt | grep "Not After :" | sed 's/^.*: //')
						CAkeyLength=$(/usr/sbin/openssl x509 -text -noout -in /opt/var/cache/pixelserv/ca.crt | grep "Public-Key:" | sed 's/^.*: //;s/(//;s/)//')
					fi
					dcrt=$(/opt/bin/find /opt/var/cache/pixelserv/ -type f $(printf "! -name %s " ca.crt prefetch ca.key) -printf '%p\n' | sort | head -n 1)
					if [ "$dcrt" ]; then
						dcrtexpiry=$(/usr/sbin/openssl x509 -text -noout -in "$dcrt" | grep "Not After :" | sed 's/^.*: //')
						dcrtkeyLength=$(/usr/sbin/openssl x509 -text -noout -in "$dcrt" | grep "Public-Key:" | sed 's/^.*: //;s/(//;s/)//')
					fi
					printf " This manages pixelserv-tls certificates.\\n Enter option to see what it does.\\n\\n"
					printf " 1. Purge pixelserv-tls domain certificates\\n"
					[ "$dcrtexpiry" ] && printf "    Expire on:  ${GREEN}$dcrtexpiry${NC}\\n    Key length: ${GREEN}$dcrtkeyLength${NC}\\n\\n"
					printf " 2. Re-generate pixelserv-tls CA certificate\\n    (ca.crt, ca.key).\\n"
					[ "$CAexpiry" ] && printf "    Expires on: ${GREEN}$CAexpiry${NC}\\n    Key length: ${GREEN}$CAkeyLength${NC}\\n"
					while true; do
						printf "\\n Enter selection [1-2 e=Exit] ";read -r continue
						case "$continue" in
							1)	if [ "$psState" = "off" ]; then
									lastError=" pixelserv-tls is inactive. Enable it first."
									reload_menu
								fi
								print_red_line
								printf " This purges all domain certificates generated\\n by pixelserv-tls.\\n"
								printf "\\n This is necessary when the ca.crt and ca.key\\n"
								printf " were replaced or when an update of pixelserv-tls\\n requires to delete old certificates.\\n"
								while true; do
									printf "\\n Continue? [1=Yes e=Exit] ";read -r continue
									case "$continue" in
										1)	print_red_line
											purge_ps_certs
											lastAction=" pixelserv-tls domain certificates purged"
											break;;
									 [Ee])	print_red_line;ep_function;break;;
										*)	printf "\\n input is not an option\\n\\n";;
									esac
								done
								break;;
							2)	if [ "$psState" = "off" ]; then
									lastError=" pixelserv-tls is inactive. Enable it first."
									reload_menu
								fi
								print_red_line
								printf " This re-generates the pixelserv-tls CA certificate\\n and purges all domain certificates genereated\\n by it.\\n"
								printf "\\n This is necessary with elevated requirements\\n"
								printf " enforced by Apple and other Companies.\\n\\n"
								printf " The new pixelserv-tls CA certificate will need to\\n be replaced or imported into browsers and devices.\\n"
								while true; do
									printf "\\n Continue? [1=Yes e=Exit] ";read -r continue
									case "$continue" in
										1)	print_red_line
											[ "$(nvram get ntp_ready)" = "1" ] && echo "${OK} NTP date is synced"
											if [ "$(nvram get ntp_ready)" = "0" ]; then
												lastError=" NTP date and time not synced.\\n Make sure your router syncs the time with an\\n NTP Server in Administration / System."
												reload_menu
											fi

											echo
											echo "${INFO} Creating new pixelserv-tls CA certificate"

											mkdir /tmp/diversion
											if [ -f /tmp/etc/openssl.cnf ]; then
												cp /tmp/etc/openssl.cnf /tmp/diversion/div-openssl.cnf
												sed -i "/\[ v3_ca \]/aextendedKeyUsage = serverAuth" /tmp/diversion/div-openssl.cnf
												sed -i 's/^default_bits.*/default_bits		= 2048/' /tmp/diversion/div-openssl.cnf
											else
												get_file div-openssl.cnf new /tmp/diversion >/dev/null
											fi

											echo "${GRAY}"

											mv /opt/var/cache/pixelserv/ca.* /opt/var/cache

											cd /opt/var/cache/pixelserv
											/usr/sbin/openssl genrsa -out ca.key 2048
											/usr/sbin/openssl req -key ca.key -new -x509 -days 3650 -sha256 -extensions v3_ca -out ca.crt -subj "/CN=Pixelserv CA" -config /tmp/diversion/div-openssl.cnf
											cd
											echo "${NC}"

											[ -d /opt/var/cache/pixelserv ] && chown -R nobody /opt/var/cache/pixelserv
											rm -rf /tmp/diversion
											if [ -f /opt/var/cache/pixelserv/ca.crt ] && [ -f /opt/var/cache/pixelserv/ca.key ]; then
												rm -f /opt/var/cache/ca.*
												echo "${OK} New pixelserv-tls CA certificate generated"
											else
												mv /opt/var/cache/ca.* /opt/var/cache/pixelserv
												lastError=" pixelserv-tls CA certificate creation failed,\\n existing certificate restored."
												reload_d_menu
											fi

											purge_ps_certs
											lastAction=" New pixelserv-tls CA certificate generated and\\n domain certificates purged.\\n\\n${NC} Remember to replace or import the new pixelserv-tls\\n certificate into browsers and devices.\\n Open ${GREEN}$psIP/ca.crt${NC} in a browser."
											break;;
									 [Ee])	print_red_line;ep_function;break;;
										*)	printf "\\n input is not an option\\n\\n";;
									esac
								done
								break;;
						 [Ee])	reload_menu;break;;
							*)	printf "\\n input is not an option\\n";;
						esac
					done
					break;;
				4)	if [ "$psState" = "off" ]; then
						lastError=" pixelserv-tls is inactive. Enable it first."
						reload_menu
					fi
					on_off_pixelserv on restart

					if [ "$?" = "0" ]; then
						lastAction=" pixelserv-tls restarted"
					else
						lastError=" pixelserv-tls failed to restart"
					fi
					break;;
				5)	break;;
				6)	break;;
			 [Ee])  exit_message;break;;
				*)	printf "\\n input is not an option\\n";;
			esac
			}
		entloop
	done

	if [ "$continue" = "5" ]; then
		print_red_line
		printf " This changes the pixelserv-tls IP address.\\n\\n"
		printf " 1. Change pixelserv-tls IP ${GREEN}$psIP${NC}\\n"

		while true; do
			entloop(){
				printf "\\n Enter your selection [$min-$max e=Exit] ";read -r continue
				case "$continue" in
					1)	print_red_line
						oldpsIP=$psIP
						get_file install.div include >/dev/null
						select_ip "pixelserv-tls IP"
						psIP=$setIP
						if [ "$psState" = "on" ]; then
							blockingIP=$psIP
						elif [ "$psState" = "off" ] || [ -z "$psState" ]; then
							blockingIP=0.0.0.0
						fi
						write_conf_file
						if [ "$(nvram get enable_acc_restriction)" = "1" ]; then
							nvram set restrict_rulelist=$(nvram get restrict_rulelist | sed "s|<1>$oldpsIP>1||g")
							acknotice=1
							set_access_restriction $psIP "pixelserv-tls"
						fi
						ifconfig br0:pixelserv-tls $oldpsIP down
						on_off_pixelserv on restart
						restart_DNSMASQ
						lastAction=" pixelserv-tls IP changed from\\n $oldpsIP to $psIP"
						break;;
				 [Ee])	print_red_line;ep_function;break;;
					*)	printf "\\n input is not an option\\n";;
				esac
				}
			entloop
		done
	elif [ "$continue" = "6" ]; then
		if [ "$EN" = "1" ]; then
			min=4 max=5
		elif [ "$EN" -ge "2" ]; then
			if [ "$LANblockingIP" ] && [ "$LANblockingIP" = "on" ]; then
				min=4 max=5
			else
				min=1 max=5
				oldpsv=$psVersion
			fi
		fi

		print_red_line
		printf " This updates installed Entware packages.\\n\\n"
		printf " Entware version: ${GREEN}$entVersion${NC}\\n"
		if [ "$(uname -m)" = "mips" ]; then
			[ "$(grep 'maurerr.github.io' /opt/etc/opkg.conf)" ] && bpe="${GREEN}on${NC}" || bpe=off
			[ "$bpe" != "off" ] && bptext=" with updates from\\n ${GREEN}maurerr.github.io${NC}" || bptext=
		fi
		printf " Installed from: ${GREEN}$(echo $(awk 'NR == 1 {print $3}' /opt/etc/opkg.conf) | sed 's#http[s]*://##;s#/.*##')${NC}$bptext\\n"
		echo
		if [ "$EN" -ge "2" ]; then
			if [ "$LANblockingIP" ] && [ "$LANblockingIP" = "off" ] || [ -z "$LANblockingIP" ]; then
				printf " 1. show pixelserv-tls info\\n"
				printf " 2. show installed packages\\n"
				printf " 3. update or upgrade pixelserv-tls\\n"
			fi
		fi
		printf " 4. update list of available packages\\n"
		printf " 5. update and upgrade installed packages\\n"
		if [ "$bpe" ]; then
			printf " 6. Parallel use Entware-backports Repo $bpe\\n"
			max=6
		fi
		while true; do
			entloop(){
				printf "\\n Enter selection [$min-$max e=Exit] ";read -r continue
				if [ "$continue" -eq "$continue" 2>/dev/null ]; then
					if [ "$continue" -lt "$min" ] || [ "$continue" -gt "$max" ]; then
						printf "\\n input is not an option\\n"
						entloop;return 1
					fi
				fi
				case "$continue" in
					1)	echo;print_red_line
						printf " pixelserv-tls info:\\n\\n"
						opkg info pixelserv-tls | sed -e 's/^/ /'
						press_enter_to "return to Menu"
						print_red_line;ep_function;break;;
					2)	echo;print_red_line
						printf " Installed Entware packages:\\n\\n"
						opkg list-installed | sed -e 's/^/ /';echo
						press_enter_to "return to Menu"
						print_red_line;ep_function;break;;
					3)	print_red_line
						printf " This updates or upgrades pixelserv-tls ${GREEN}$psVersion${NC}\\n\\n"

						printf " 1. Update pixelserv-tls, regular Entware version\\n"
						printf " 2. Upgrade pixelserv-tls, regular Entware version\\n"
						noad=;popt=2
						if [ "$(uname -m)" = "mips" ]; then
							printf " 3. Upgrade pixelserv-tls to v2.3.1, Jack Yaz version\\n"
							noad=3;popt=3
						fi
						while true; do
							printf "\\n Enter your selection [1-$popt e=Exit] ";read -r continue
							case "$continue" in
								1)		echo "${GRAY}"
										opkg update pixelserv-tls
										if [ "$?" -ne "1" ]; then
											check_ps_version
											if [ "$oldpsv" != "$psVersion" ]; then
												on_off_pixelserv on restart
												lastAction=" Entware packages action:\n pixelserv-tls updated to $psVersion"
											else
												lastAction=" Entware packages action:\n no pixelserv-tls update available"
											fi
										else
											lastError=" Entware packages action:\n update pixelserv-tls failed, network error"
										fi
										echo "${NC}"
										reload_menu;break;;
								2)		echo "${GRAY}"
										opkg update >/dev/null
										opkg upgrade pixelserv-tls
										if [ "$?" -ne "1" ]; then
											check_ps_version
											if [ "$oldpsv" != "$psVersion" ]; then
												on_off_pixelserv on restart
												lastAction=" Entware packages action:\n pixelserv-tls upgraded to $psVersion"
											else
												lastAction=" Entware packages action:\n no pixelserv-tls upgrade available"
											fi
										else
											lastError=" Entware packages action:\n upgrade failed, network error"
										fi
										echo "${NC}"
										reload_menu;break;;
							[$noad])	print_red_line
										printf " This upgrades pixelserv-tls to v2.3.1, Jack Yaz version.\\n This version is compliant with the new required\\n"
										printf " security settings enforced by Apple and other Companies.\\n See https://github.com/jackyaz/pixelserv-tls/releases/tag/2.3.1\\n\\n"
										printf " It will install the  appropriate version for your\\n $entVersion installation.\\n\\n"
										printf " After successful upgrade, purge and re-generate the\\n CA certificate in ${RED_BG} ep ${NC}, 3, 2.\\n"

										[ "$(grep 'maurerr.github.io' /opt/etc/opkg.conf)" ] && printf "\\n${INFO} Entware packport is enabled.\\n Entware (backport) packages will be updated before\\n the pixelserv-tls update runs.\\n"
										continue_dialog

										print_red_line
										if [ "$oldpsv" = v2.3.1 ]; then
											lastError=" pixelserv-tls v2.3.1 is already installed."
											reload_menu
										fi

										case "$(uname -m)" in
											mips)		PS_FILE='pixelserv-tls_2.3.1-1_mipselsf.ipk'
														if [ "$(grep 'maurerr.github.io' /opt/etc/opkg.conf)" ]; then
															PS_FILE='pixelserv-tls_2.3.1-1_mipselsf-backport.ipk'
															echo "${INFO} Updating Entware (backport) packages"
															echo "${GRAY}"
															opkg update >/dev/null
															opkg upgrade
															echo "${NC}"
														fi
														;;
											*)			lastError=" $(uname -m) is an unsupported platform\\n to install pixelserv-tls v2.3.1."
														reload_menu;;
										esac

										[ -f "/tmp/$PS_FILE" ] && rm "/tmp/$PS_FILE"

										echo "${INFO} Downloading pixelserv-tls"

										echo "${GRAY}"
											/usr/sbin/curl --location --connect-timeout 10 --retry 3 "https://github.com/jackyaz/pixelserv-tls/releases/download/2.3.1/$PS_FILE" -o "/tmp/$PS_FILE"
										echo "${NC}"

										if [ -f "/tmp/$PS_FILE" ]; then
											echo "${INFO} Download successful, installing..."
										else
											echo "${NOK} Download failed"
											lastError=" Download of pixelserv-tls v2.3.1 failed"
											reload_menu
										fi

										echo "${GRAY}"
											opkg install "/tmp/$PS_FILE"
										echo "${NC}"

										[ -f "/tmp/$PS_FILE" ] && rm "/tmp/$PS_FILE"

										check_ps_version

										if [ "$oldpsv" != "$psVersion" ]; then
											on_off_pixelserv on restart
											lastAction=" pixelserv-tls updated to $psVersion.\\n Now purge and re-generate the CA certificate in\\n ${NC}${RED_BG} ep ${NC}, 3, 2 and read instructions."
										else
											lastAction=" Failed to update pixelserv-tls"
											reload_menu
										fi
										break;;
							[Ee])		exit_message;reload_menu;break;;
								*)		printf "\\n input is not an option\\n";;
							esac
						done
						break;;
					4)	echo "${GRAY}"
						opkg update
						if [ "$?" -ne "1" ]; then
							if [ "$LANblockingIP" ] && [ "$LANblockingIP" = "off" ] || [ -z "$LANblockingIP" ]; then
								[ "$EN" -ge "2" ] && check_ps_version
								[ "$EN" -ge "2" ] && [ "$oldpsv" != "$psVersion" ] && on_off_pixelserv on restart
							fi
							lastAction=" Entware packages action:\\n updated available packages list"
						else
							lastError=" Entware packages action:\n update packages list failed, network error"
						fi
						echo "${NC}"
						reload_menu;break;;
					5)	echo "${GRAY}"
						opkg update
						opkg upgrade
						if [ "$?" -ne "1" ]; then
							if [ "$LANblockingIP" ] && [ "$LANblockingIP" = "off" ] || [ -z "$LANblockingIP" ]; then
								[ "$EN" -ge "2" ] && check_ps_version
								[ "$EN" -ge "2" ] && [ "$oldpsv" != "$psVersion" ] && on_off_pixelserv on restart
							fi
							lastAction=" Entware packages action:\\n all packages upgraded"
						else
							lastError=" Entware packages action:\n upgrade failed, network error"
						fi
						echo "${NC}"
						reload_menu;break;;
					6)	print_red_line
						echo " Parallel use of Entware-backports Repo is $bpe"
						if [ "$bpe" != "off" ]; then
							while true; do
								printf "\\n Disable it? [1=Yes e=Exit] ";read -r confirm
								case "$confirm" in
									1)	sed -i '/pkg.entware-backports.tk/d' /opt/etc/opkg.conf
										sed -i '/maurerr.github.io/d' /opt/etc/opkg.conf
										lastAction=" Entware-backports Repo disabled"
										reload_menu;break;;
								 [Ee])	exit_message;break;;
									*)	printf "\\n input is not an option\\n";;
								esac
							done
						else
							echo
							echo " This repository for MIPS based routers receives"
							echo " updated Entware packages until December 2019,"
							echo " while the original repo does not."
							echo
							echo " The additional backports source is added:"
							echo " - maurerr.github.io/packages"
							echo
							echo " Maintained by @maurer, see this thread for details:"
							echo " https://www.snbforums.com/threads/mips-entware-backports-repo-entware-ng-reloaded.49468/"
							while true; do
								printf "\\n Enable it? [1=Yes e=Exit] ";read -r confirm
								case "$confirm" in
									1)	sed -i '2i\src/gz entware-backports-mirror https://maurerr.github.io/packages' /opt/etc/opkg.conf
										lastAction=" Entware-backports Repo enabled"
										print_red_line
										echo " Do you want to update and upgrade all packages now?"
										while true; do
											printf "\\n Enter your selection [1=Yes e=Exit] ";read -r confirm
											case "$confirm" in
												1)	echo "${GRAY}"
													opkg update >/dev/null
													opkg upgrade
													if [ "$?" -ne "1" ]; then
														if [ "$LANblockingIP" ] && [ "$LANblockingIP" = "off" ] || [ -z "$LANblockingIP" ]; then
															[ "$EN" -ge "2" ] && check_ps_version
															[ "$EN" -ge "2" ] && [ "$oldpsv" != "$psVersion" ] && on_off_pixelserv on restart
														fi
														lastAction="$lastAction\\n Entware packages action: all packages upgraded"
													else
														lastError="$lastAction\\n Entware packages action: upgrade failed, network error"
													fi
													echo "${NC}"
													reload_menu;break;;
											 [Ee])	break;;
												*)	printf "\\n input is not an option\\n";;
											esac
										done
										reload_menu;break;;
								 [Ee])	exit_message;break;;
									*)	printf "\\n input is not an option\\n";;
								esac
							done
						fi
						reload_menu;break;;
				 [Ee])  print_red_line;ep_function;break;;
					*)	printf "\\n input is not an option\\n";;
				esac
				}
			entloop
		done
	fi
}

add_switches(){
	print_red_line
	printf " Available switches through $NAME:\\n\\n"
	printf " -2 disable HTTP 204 reply to generate_204 URLs\\n"
	printf " -A ADMIN_PORT (HTTPS only. Default is none)*\\n"
	printf " -c cache size (default 100)*\\n"
	printf " -k https_port (443 if omitted)* **\\n"
	printf " -l logging to Syslog, levels: 0: critical 1: error (default)\\n    2: warning 3: notice 4: info 5: debug (1 if omitted)*\\n"
	printf " -n iface (all interfaces if omitted)*\\n"
	printf " -O keep-alive duration for HTTP/1.1 connections (default: 120s)*\\n"
	printf " -p http_port (80 if omitted)* **\\n"
	printf " -R disable redirect to encoded path in tracker links\\n"
	printf " -T max_service_threads (default: 1200)*\\n"
	printf " -u user (\"nobody\" if omitted)*\\n"
	printf "\\n For full description see here:\\n https://github.com/kvic-z/pixelserv-tls/wiki/Command-Line-Options\\n"

	printf "\\n *)  requires additional parameter\\n"
	printf " **) iptables rules need to be set to redirect\\n     the queries to new port(s).\\n"
	printf "     Both ports need to be set, even if one\\n     remains at default setting\\n"
	echo
	printf " These switches are in use (none if none are listed):\\n"
	switchesFile="${DIVERSION_DIR}/.conf/pixelserv.switches"
	if [ ! -f "$switchesFile" ]; then
		>$switchesFile
	fi
	i=1; cat $switchesFile | while IFS= read line; do
		printf " $i: $line\\n"
		i=$((i+1))
	done
	print_red_line
	printf " 1. Add switch\\n 2. Remove switch\\n 3. Commit and restart pixelserv-tls\\n"
	while true; do
		printf "\\n Enter selection [1-3 e=Exit] ";read -r continue
		case "$continue" in
			1)	while true; do
					print_red_line
					printf " Add switch (e.g. -f). You will be prompted to\\n enter an additional parameter if required.\\n"
					printf "\\n${RED_BG} Enter switch ${NC} [-? q=Quit] ";read -r switchesadd
					case "$switchesadd" in
						[Qq])	add_switches;break;;
				-f|-s|-t|-z)	printf "\\n${RED} The ${NC}$switchesadd${RED} switch is not available in Diversion,${NC}\\n"
								printf "${RED} it would break the automatic system check.${NC}\\n\\n";;
						-2|-R)	echo "$switchesadd" >>$switchesFile
								add_switches;break;;
	-A|-c|-k|-l|-n|-O|-p|-T|-u) 	printf "\\n${RED_BG} Enter parameter ${NC} [q=Quit] ";read -r parameter
								case "$parameter" in
									[Qq])	add_switches;break;;
									   *)	echo "$switchesadd $parameter" >>$switchesFile
											lastAction=" added pixelserv-tls switches:\\n $(cat $switchesFile | tr '\n' ' ')"
											add_switches;break;;
								esac;break;;
						  *)	printf "\\n input is not an option\\n";;
					esac
				done
				break;;
			2)	printf "\\n${RED_BG} Enter line no. to remove ${NC} [q=Quit] ";read -r deleteline
				case $deleteline in
					[Qq])	add_switches;break;;
					   *)	sed -i "${deleteline}d" $switchesFile
							lastAction=" removed pixelserv-tls switches."
							add_switches;break;;
				esac
				break;;
			3)	on_off_pixelserv on restart
				[ -z "$lastAction" ] && lastAction=" restarted pixelserv-tls."
				reload_menu;break;;
		 [Ee])  exit_message;break;;
			*)	printf "\\n input is not an option\\n";;
		esac
	done
}

f_function(){
	if ! grep -wq "log-facility" /etc/dnsmasq.conf; then
		lastError=" logging is disabled, enable it first."
		reload_menu
	fi
	check_filter(){
		ginv=
		print_red_line
		echo "${INFO} To invert the filter, precede term by a dash (-)"
		echo "${SPACE} e.g. -domain.com"
		printf "\\n${RED_BG} Enter term to filter by ${NC} [q=Quit] ";read -r filterTerm
		filterTerm=$(echo $filterTerm | sed 's/http[s]*:\/\///;s|\/.*||')
		case "$filterTerm" in
			 *\**) 	echo;echo "${RED} filter term contains star (*), this cannot work${NC}"
					check_filter;;
			 -*) 	echo;echo "${GREEN} preceding dash detected, inverting filtering${NC}"
					filterTerm=$(echo $filterTerm  | sed 's/^-//')
					ginv=-v;;
				q)	print_red_line;f_function;;
		esac
	}
	echo "${INFO} This follows the Dnsmasq log file (tail -F)"

	echo
	echo " 1. Unfiltered log"
	echo " 2. Unfiltered log extra highlighted"
	echo " 3. Blocked domains"
	echo " 4. Blocked domains, by device IP"
	echo " 5. Term or IP"
	while true; do
		printf "\\n Enter selection [1-5 e=Exit] ";read -r continue
		case "$continue" in
			1)	print_red_line
				tail_logfile "$continue";break;;
			2)	tail_logfile "$continue";break;;
			3)	tail_logfile "$continue";break;;
			4)	print_red_line
				echo "${INFO} To only see blocked domains from a single"
				echo "${SPACE} device, enter its assigned IP address."
				select_device_IP(){
					deviceIP=;deviceIPOK=
					while true; do
						printf "\\n${RED_BG} Enter device IP to filter by ${NC} [q=Quit] ";read -r deviceIP
						case "$deviceIP" in
							q)	print_red_line;f_function;break;;
							*)	lan_ipaddr=$(nvram get lan_ipaddr)
								if [ "$deviceIP" = "$lan_ipaddr" ]; then
									printf "\\n${NOK} $deviceIP is this routers address\\n"
									select_device_IP
									return 1
								fi
								if ! expr "$deviceIP" : '[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*$' >/dev/null; then
									printf "\\n${NOK} $deviceIP is not a valid IP address\\n"
									select_device_IP
									return 1
								fi
								if [ "$(printf "$lan_ipaddr" | sed 's/\.[0-9]*$/./')" = "$(printf "$deviceIP" | sed 's/\.[0-9]*$/./')" ]; then
									printf "\\n${OK} $deviceIP is a valid IP address\\n"
									deviceIPOK=1
								else
									printf "\\n${NOK} $deviceIP is not a router address\\n"
									select_device_IP
									return 1
								fi
								if [ "$deviceIPOK" = 1 ]; then
									if ! grep -q 'log-queries=extra' /etc/dnsmasq.conf; then
										touch /tmp/diversion-loqQueriesExtra
										restart_DNSMASQ
									fi
									tail_logfile "$continue"
								fi
								break;;
						esac
					done
				}
				select_device_IP
				break;;
			5)	check_filter
				tail_logfile "$continue";break;;
		 [Ee])  exit_message;break;;
			*) 	printf "\\n input is not an option\\n";;
		esac
	done
	check_dnsmasq_redirect
}

tail_logfile(){
	fopt=$1
	echo
	trap lf_option 2
	lf_option(){
		echo
		print_red_line
		echo " Enter selection"
		echo
		echo " 1. Continue follow logfile"
		echo " 2. Select other follow option"
		echo " 3. Return to menu"
		while true; do
			printf "\\n Enter selection [1-3 e=Exit] ";read -r continue
			case "$continue" in
				1)	tail_logfile $fopt;break;;
				2)	print_red_line
					if [ -f /tmp/diversion-restartDnsmasq ]; then
						restart_DNSMASQ
						rm /tmp/diversion-restartDnsmasq
					fi
					f_function;break;;
			[Ee]|3)	trap - 2
					if [ -f /tmp/diversion-restartDnsmasq ]; then
						restart_DNSMASQ
						rm /tmp/diversion-restartDnsmasq
					fi
					reload_menu;break;;
				*) 	printf "\\n input is not an option\\n";;
			esac
		done
	}

	highlighted(){
		follow_dnsmasq_alternate_bl

		echo "${INFO} Press Ctrl-C to exit"
		echo
		tail -F "${LOG_DIR}/dnsmasq.$log" | \
		while read line; do
			if echo "$line" | /opt/bin/grep -q "list/blockinglist\|list/blacklist\| config .* is $blockingIP"; then
				echo "${RED}$( echo "$line" | sed 's|/opt/share/diversion/list/|blocked by |;s|config|blocked by wc-blacklist|')${NC}"
			elif echo "$line" | /opt/bin/grep -q " forwarded "; then
				echo "${YELLOW}$line${NC}"
			elif echo "$line" | /opt/bin/grep -q " query\[A.* "; then
				echo "${GREEN}$line${NC}"
			elif echo "$line" | /opt/bin/grep -q " cached "; then
				echo "${BLUE}$line${NC}"
			else
				echo "${GRAY}$line${NC}"
			fi
		done
	}

	blocked_domains(){
		follow_dnsmasq_alternate_bl
		echo "${INFO} Press Ctrl-C to exit"
		echo
		tail -F "${LOG_DIR}/dnsmasq.$log" | \
		while read line; do
			if echo "$line" | /opt/bin/grep -q "list/blockinglist\|list/blacklist\| config .* is $blockingIP"; then
				printf "%-43s%s\\n" "${GRAY} $( echo $line | awk '{print $3, "blocked by " $(NF-3)}' | sed 's|/opt/share/diversion/list/||;s|config|wc-blacklist|')${NC} " "${RED}$( echo $line | awk '{print $(NF-2)}')${NC}"
			fi
		done
	}

	blocked_domains_by_IP(){
		follow_dnsmasq_alternate_bl
		echo "${INFO} Filtering by IP $deviceIP"
		echo
		echo "${INFO} Press Ctrl-C to exit"
		echo
		tail -F "${LOG_DIR}/dnsmasq.$log" | \
		while read line; do
			if echo "$line" | /opt/bin/grep -q "list/blockinglist\|list/blacklist\| config .* is $blockingIP" && echo "$line" | /opt/bin/grep -q " $(echo $deviceIP | sed -e 's/\./\\./g')/"; then
				printf "%-43s%s\\n" "${GRAY} $( echo $line | awk '{print $3, "blocked by " $(NF-3)}' | sed 's|/opt/share/diversion/list/||;s|config|wc-blacklist|')${NC} " "${RED}$( echo $line | awk '{print $(NF-2)}')${NC}"
			fi
		done
	}

	filtered(){
		follow_dnsmasq_alternate_bl
		echo "${INFO} Press Ctrl-C to exit"
		echo
		tail -F "${LOG_DIR}/dnsmasq.$log" | \
		while read line; do
			if echo "$line" | /opt/bin/grep $ginv "$filterTerm"; then
				echo "$line" | sed -E \
				-e "s,($(date +'%b %d ')| dnsmasq[.*[0-9]]),,g" \
				-e "s,/opt/share/diversion/list/,blocked by ,g" \
				-e "/is $blockingIP/ s/ config / blocked by wc-blacklist /" \
				-e "s,(.*(blockinglist|blacklist| wc-blacklist ).* is ${blockingIP}.*),${RED}&${NC}," \
				-e "s,.*(query\\[A|DHCP).*,${NC}&${NC}," \
				-e "s,.*,${GRAY}&${NC},"
			fi
		done
	}

	[ "$fopt" = "1" ] && follow_dnsmasq
	[ "$fopt" = "2" ] && highlighted
	[ "$fopt" = "3" ] && blocked_domains
	[ "$fopt" = "4" ] && blocked_domains_by_IP
	[ "$fopt" = "5" ] && filtered
}

check_dnsmasq_redirect(){
	if grep -wq "127.0.0.1" /etc/dnsmasq.conf; then
		printf "\\n${NOK} Dnsmasq entry detected,\\n${SPACE} redirecting hosts to 127.0.0.1\\n"
		printf "${ATTN} Be aware that log file entries with '127.0.0.1'\\n"
		printf "${SPACE} are from another script, not $NAME${NC}\\n"
		press_enter_to acknowledge
	fi
}

ds_function(){
	case "$dsSetting" in
		on) dsColor="${GREEN}";;
		 *)	dsColor="${NC}";;
	esac
	restart=
	echo " Dnsmasq settings:"
	echo
	echo " See the Dnsmasq man page what these options do:"
	echo " http://www.thekelleys.org.uk/dnsmasq/docs/dnsmasq-man.html"
	echo
	if [ -z "$dsSetting" ] || [ "$dsSetting" = "off" ]; then
		echo " Note: Settings are not active when Dnsmasq"
		echo " settings are disabled."
		echo
		echo " 1. ${GREEN}Enable${NC} Dnsmasq settings"
	else
		echo " 1. ${RED}Disable${NC} Dnsmasq settings"
	fi
	echo " 2. log-async         ${dsColor}$logAsync${NC}"
	echo " 3. cache-size        ${dsColor}$cacheSize${NC}"
	echo " 4. bogus-priv        ${dsColor}$bogusPriv${NC}"
	echo " 5. domain-needed     ${dsColor}$domainNeeded${NC}"
	echo " 6. log-queries=extra ${dsColor}$loqQueriesExtra${NC}"
	while true; do
		printf "\\n Enter selection [1-6 e=Exit] ";read -r continue
		read_conf_file
		case "$continue" in
			1)	[ -z "$dsSetting" ] || [ "$dsSetting" = "off" ] && dsSetting=on || dsSetting=off
				restart=1;break;;
			2)	print_red_line
				printf " Select the value for log-async\\n\\n"
				printf " 0. off\\n 1. 5 (default)\\n 2. 10\\n 3. 15\\n 4. 20\\n"
				printf " 5. 25\\n 6. 30\\n 7. 40\\n 8. 50\\n 9. 100 (!)\\n"
				while true; do
					printf "\\n Set log-async [0-9 e=Exit] ";read -r continue
					case "$continue" in
						0)	logAsync=;break;;
						1)	logAsync=5;break;;
						2)	logAsync=10;break;;
						3)	logAsync=15;break;;
						4)	logAsync=20;break;;
						5)	logAsync=25;break;;
						6)	logAsync=30;break;;
						7)	logAsync=40;break;;
						8)	logAsync=50;break;;
						9)	logAsync=100;break;;
					 [Ee])	print_red_line;ds_function;break;;
						*) 	printf "\\n input is not an option\\n";;
					esac
				done
				[ "$dsSetting" = "on" ] && restart=1
				break;;
			3)	print_red_line
				printf " Select the value for cache-size\\n\\n"
				printf " 0. off\\n 1. 500\\n 2. 1000\\n 3. 1500 (default)\\n 4. 2000\\n"
				printf " 5. 2500\\n 6. 3000\\n 7. 4000\\n 8. 5000\\n 9. 10000 (may cause performance issues!)\\n"
				while true; do
					printf "\\n Set cache-size [0-9 e=Exit] ";read -r continue
					case "$continue" in
						0)	cacheSize=;break;;
						1)	cacheSize=500;break;;
						2)	cacheSize=1000;break;;
						3)	cacheSize=1500;break;;
						4)	cacheSize=2000;break;;
						5)	cacheSize=2500;break;;
						6)	cacheSize=3000;break;;
						7)	cacheSize=4000;break;;
						8)	cacheSize=5000;break;;
						9)	cacheSize=10000;break;;
					 [Ee])	print_red_line;ds_function;break;;
						*) 	printf "\\n input is not an option\\n";;
					esac
				done
				[ "$dsSetting" = "on" ] && restart=1
				break;;
			4)	print_red_line
				printf " Set status of bogus-priv\\n\\n"
				printf " 0. off\\n 1. on\\n"
				while true; do
					printf "\\n Set bogus-priv [0-1 e=Exit] ";read -r continue
					case "$continue" in
						0)	bogusPriv=;break;;
						1)	bogusPriv=on;break;;
					 [Ee])	print_red_line;ds_function;break;;
						*) 	printf "\\n input is not an option\\n";;
					esac
				done
				[ "$dsSetting" = "on" ] && restart=1
				break;;
			5)	print_red_line
				printf " Set status of domain-needed\\n\\n"
				printf " 0. off\\n 1. on\\n"
				while true; do
					printf "\\n Set domain-needed [0-1 e=Exit] ";read -r continue
					case "$continue" in
						0)	domainNeeded=;break;;
						1)	domainNeeded=on;break;;
					 [Ee])	print_red_line;ds_function;break;;
						*) 	printf "\\n input is not an option\\n";;
					esac
				done
				[ "$dsSetting" = "on" ] && restart=1
				break;;
			6)	print_red_line
				printf " Set status of log-queries=extra\\n\\n"
				printf " 0. off\\n 1. on\\n"
				while true; do
					printf "\\n Set log-queries=extra [0-1 e=Exit] ";read -r continue
					case "$continue" in
						0)	loqQueriesExtra=;break;;
						1)	loqQueriesExtra=on;break;;
					 [Ee])	print_red_line;ds_function;break;;
						*) 	printf "\\n input is not an option\\n";;
					esac
				done
				[ "$dsSetting" = "on" ] && restart=1
				break;;
		 [Ee])	exit_message;reload_menu;break;;
			*) 	printf "\\n input is not an option\\n";;
		esac
	done
	write_conf_file
	[ "$restart" ] && restart_DNSMASQ
	print_red_line
	ds_function
}

el_function(){
	todayHour=$(date +"%F_%H.%M")
	read_conf_file
	[ -z "$edited_whitelist" ] && edited_whitelist=
	[ -z "$edited_blacklist" ] && edited_blacklist=
	[ -z "$edited_wc_blacklist" ] && edited_wc_blacklist=
	[ -z "$editorColor" ] && editorColor=on
	[ -z "$editorPaginate" ] && editorPaginate=20
	[ -z "$editorAutowww" ] && editorAutowww=off

	printf " Edit lists options\\n\\n This fine tunes the ${GREEN}blocking list${NC} ${RED_BG} b ${NC}\\n\\n"
	printf " - The ${GREEN}whitelist${NC} deletes exact domains found in\\n   the blocking list and both blacklists.\\n"
	printf "   Note:\\n${GREEN}   The whitelist has precedence over the blacklists.${NC}\\n\\n"
	printf " - The ${GREEN}blacklist${NC} blocks exact domains not found in\\n   the blocking list.\\n"
	printf " - The ${GREEN}wildcard-blacklist${NC} blocks everything\\n   ending with *domain.com.\\n"
	printf "\\n${RED} Edits are not active until processed${NC}\\n"

	[ "$editorColor" = "on" ] && edcolor="${GREEN}$editorColor${NC}" || edcolor=$editorColor
	echo
	[ "$hostedWL" = "on" ] && echo " 1. whitelist ${GREEN}hosted${NC} settings" || echo " 1. Edit whitelist"
	[ "$hostedBL" = "on" ] && echo " 2. blacklist ${GREEN}hosted${NC} settings" || echo " 2. Edit blacklist"
	[ "$hostedWCBL" = "on" ] && echo " 3. wildcard-blacklist ${GREEN}hosted${NC} settings" || echo " 3. Edit wildcard-blacklist"

	[ "$hostedWL" = "on" ] || [ "$hostedBL" = "on" ] || [ "$hostedWCBL" = "on" ] && hwltext="Re-download and process" || hwltext="Process"
	echo " 4. $hwltext all lists"
	[ "$editorPaginate" = "off" ] && edp=off || edp="${GREEN}$editorPaginate${NC}"
	echo " 5. List Settings: Colors $edcolor, Pagination $edp"
	if [ "$hostedWL" = "on" ]; then
		echo "${GRAY}    Auto-add www/non-www domain $editorAutowww${NC}"
	else
		echo "    Auto-add www/non-www domain ${GREEN}$editorAutowww${NC}"
	fi

	echo " 6. Delete backup files ($(ls "${DIVERSION_DIR}/backup"/*-whitelist "${DIVERSION_DIR}/backup"/*-blacklist "${DIVERSION_DIR}/backup"/*-wc_blacklist 2> /dev/null | wc -l))"

	while true; do
		printf "\\n Enter your selection [1-6 e=Exit] ";read -r continue
		case "$continue" in
			1)	[ "$hostedWL" = "on" ] && hosted_lists whitelist || edit_list edit whitelist;break;;
			2)	[ "$hostedBL" = "on" ] && hosted_lists blacklist || edit_list edit blacklist;break;;
			3)	[ "$hostedWCBL" = "on" ] && hosted_lists wc_blacklist || edit_list edit wc_blacklist;break;;
			4)	edit_list process 7;break;;
			5)	while true; do
					print_red_line
					[ "$editorColor" = "on" ] && edcolor=off || edcolor="${GREEN}on${NC}"
					[ "$editorAutowww" = "on" ] && wwwcolor=off || wwwcolor="${GREEN}on${NC}"
					printf " 1. Set list colors to $edcolor\\n"
					if [ "$editorPaginate" = "off" ]; then
						printf " 2. Set list pagination to ${GREEN}on${NC}\\n"
					else
						printf " 2. Set list pagination ${GREEN}$editorPaginate${NC}\\n"
					fi
					if [ "$hostedWL" = "on" ]; then
						printf "${GRAY} 3. Set Auto-www/non-www to $editorAutowww (local whitelist only)${NC}\\n"
						elo=2;noad=
					else
						printf " 3. Set Auto-www/non-www to $wwwcolor (local whitelist only)\\n"
						elo=3;noad=3
					fi
					while true; do
						printf "\\n Enter your selection [1-$elo e=Exit] ";read -r continue
						case "$continue" in
							1)	[ "$editorColor" = "on" ] && editorColor=off || editorColor=on
								write_conf_file;print_red_line;el_function;break;;
							2)	while true; do
									print_red_line
									printf " This sets the number at which pagination begins.\\n"
									printf " Note that if the remaining lines is 10 or less,\\n it will not paginate.\\n\\n"
									printf " 1. Paginate off\\n 2. Paginate at 20 lines\\n 3. Paginate at 25 lines\\n 4. Paginate at 30 lines\\n"
									printf " 5. Paginate at 35 lines\\n 6. Paginate at 40 lines\\n 7. Paginate at 50 lines\\n 8. Paginate at 60 lines\\n"
									while true; do
										printf "\\n Enter your selection [1-8 e=Exit] ";read -r continue
										case "$continue" in
											1)	editorPaginate=off
												write_conf_file;print_red_line;el_function;break;;
											2)	editorPaginate=20
												write_conf_file;print_red_line;el_function;break;;
											3)	editorPaginate=25
												write_conf_file;print_red_line;el_function;break;;
											4)	editorPaginate=30
												write_conf_file;print_red_line;el_function;break;;
											5)	editorPaginate=35
												write_conf_file;print_red_line;el_function;break;;
											6)	editorPaginate=40
												write_conf_file;print_red_line;el_function;break;;
											7)	editorPaginate=50
												write_conf_file;print_red_line;el_function;break;;
											8)	editorPaginate=60
												write_conf_file;print_red_line;el_function;break;;
										[Ee])	el_function;break;;
											*)	printf "\\n input is not an option\\n";;
										esac
									done
								done;break;;
						[$noad])	[ "$editorAutowww" = "on" ] && editorAutowww=off || editorAutowww=on
								write_conf_file;print_red_line;el_function;break;;
						[Ee])	el_function;break;;
							*)	printf "\\n input is not an option\\n";;
						esac
					done
				done;break;;
			6)	print_red_line
				sf_function rmlists;break;;
		 [Ee])	lastAction=" edited list(s)"
				if [ "$edited_whitelist" = "1" ] || [ "$edited_blacklist" = "1" ] || [ "$edited_wc_blacklist" = "1" ]; then
					print_red_line
					echo "${ATTN} There are unprocessed changes in the list(s):"
					[ "$edited_whitelist" = "1" ] && echo "${SPACE} - whitelist"
					[ "$edited_blacklist" = "1" ] && echo "${SPACE} - blacklist"
					[ "$edited_wc_blacklist" = "1" ] && echo "${SPACE} - wildcard-blacklist"

					while true; do
						printf "\\n Process now? [1=Yes 2=No] ";read -r continue
						case "$continue" in
							1)	elsum=
								[ "$edited_whitelist" = "1" ] && elsum=$((elsum+1))
								[ "$edited_blacklist" = "1" ] && elsum=$((elsum+2))
								[ "$edited_wc_blacklist" = "1" ] && elsum=$((elsum+4))
								edit_list process $elsum
								break;;
							2|[Ee])	lastAction=" Reminder:\\n Process changes in lists with ${NC}${RED_BG} el ${NC}"
								write_conf_file;break;;
							*)	printf "\\n input is not an option\\n";;
						esac
					done
				fi
				reload_menu;break;;
			*)	printf "\\n input is not an option\\n";;
		esac
	done
}

hosted_lists(){

	case "$1" in
		whitelist)		hostedList=$hostedWL
						hostetURL=$hostedWLUrl;;
		blacklist)		hostedList=$hostedBL
						hostetURL=$hostedBLUrl;;
		wc_blacklist)	hostedList=$hostedWCBL
						hostetURL=$hostedWCBLUrl;;
	esac

	add_hosted_list(){
		while true; do
			hosted_list_format $1
			printf "\\n Paste web address and press [Enter]\\n"
			printf "\\n${RED_BG} Enter list URL ${NC} [q=Quit] ";read -r hostetURL
			case "$hostetURL" in
				[Qq])	print_red_line;el_function;break;;
				*)		[ "$(echo "$hostetURL" | grep 'dropbox.com')" ] && [ "$(echo "$hostetURL" | grep 'dl=1')" ] && hostetURL="$(echo "$hostetURL" | sed "s~dl=1~dl=0~")"
						_curlhl(){ /usr/sbin/curl -s --insecure --location --connect-timeout 10 --retry 3 "$@";}
						_curlhl --head -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0" "$hostetURL" | head -n 1 | grep "HTTP/1.[01] [20]." >/dev/null
						if [ "$?" = "0" ]; then
							[ "$(echo "$hostetURL" | grep 'dropbox.com')" ] && [ "$(echo "$hostetURL" | grep 'dl=0')" ] && hostetURL="$(echo "$hostetURL" | sed "s~dl=0~dl=1~")"
							get_hosted_list $hostetURL $1
							export edited_${1}=1
						else
							printf "\\n${NOK} This address did not respond, check its validity.\\n"
							press_enter_to return
							hosted_lists $1
						fi
						break;;
			esac
		done
	}

	hosted_list_format(){
		echo
		if [ "$1" = "blacklist" ]; then
			echo "${ATTN} The format for a hosted $1 is an"
			echo "${SPACE} 'IP Domain' pair, one entry per line. Any IP"
			echo "${SPACE} is auto-converted to your blocking IP $blockingIP:"
			echo " 0.0.0.0 domain.com"
			echo " 127.0.0.1 domain.com"
			echo " 192.168.1.2 domain.com"
		else
			echo "${ATTN} The format for a hosted $1 is"
			echo "${SPACE} one domain per line:"
			echo " domain.com"
			echo " otherdomain.com"
			echo " somedomain.com"
		fi
		echo
		echo "${ATTN} The current $1 will be replaced."
	}

	print_red_line
	if [ -z "$hostedList" ] || [ "$hostedList" = "off" ]; then
		echo " Hosted $1"
		echo " This uses a hosted $1 where it can be managed"
		echo " centrally for multiple routers. It is weekly"
		echo " re-dowloaded when the blocking list updates."
		echo
		echo " The list is sorted and empty and commented"
		echo " lines are removed during the process."
		hosted_list_format $1
		printf "\\n 1. Enable hosted $1\\n"
		[ "$hostetURL" ] && printf "    ($hostetURL)\\n"
		while true; do
			printf "\\n Enter your selection [1-1 e=Exit] ";read -r continue
			case "$continue" in
				1)	if [ -z "$hostedList" ] || [ "$hostedList" = "off" ] && [ -z "$hostetURL" ]; then
						add_hosted_list $1
						hostedList=on
					else
						hostedList=on
						get_hosted_list $hostetURL $1
						export edited_${1}=1
					fi
					break;;
			 [Ee])	print_red_line;el_function;break;;
				*) 	printf "\\n input is not an option\\n";;
			esac
		done
	else
		if [ ! -s "${DIVERSION_DIR}/list/${1}" ]; then
			printf " No $1 found, re-downloading file...\\n"
			sprl=1
			get_hosted_list $hostetURL $1
			sprl=
			echo
			if [ ! -s "${DIVERSION_DIR}/list/${1}" ]; then
				printf "\\n${RED} Re-download failed from${NC}:\\n $hostetURL\\n"
				echo " Trying to restore from backup."
				restore_file $1
				echo
			fi
		fi

		noad=; hopt=3
		printf " URL of hosted $1:\\n ${GREEN}$hostetURL${NC}\\n\\n"
		printf " 1. Disable hosted $1\\n"
		printf " 2. Change $1 URL\\n"
		printf " 3. Re-download and process $1\\n"
		if [ -s "${DIVERSION_DIR}/list/${1}.removed" ]; then
			noad=4; hopt=4
			printf " 4. View auto-removed whitelisted domains (${RED}$(wc -l < ${DIVERSION_DIR}/list/${1}.removed)${NC})\\n"
		fi
		while true; do
			printf "\\n Enter your selection [1-$hopt e=Exit] ";read -r continue
			case "$continue" in
				1)			print_red_line
							printf " Do you want to keep the ${GREEN}$(wc -l < ${DIVERSION_DIR}/list/$1)${NC} entries in the ${1}?\\n\\n"
							printf " 1. Keep entries as local $1\\n"
							printf " 2. Remove entries\\n"
							while true; do
								printf "\\n Enter your selection [1-2 e=Exit] ";read -r continue
								case "$continue" in
									1)	hostedList=off
										break;;
									2)	hostedList=off
										if [ -f "${DIVERSION_DIR}/list/$1" ]; then
											cat <<-EOF > "${DIVERSION_DIR}/list/$1"

											EOF
										fi
										ubl=1
										break;;
								[Ee])	print_red_line;el_function;break;;
									*) 	printf "\\n input is not an option\\n";;
								esac
							done
							[ -f "${DIVERSION_DIR}/backup/hosted_${1}" ] && rm "${DIVERSION_DIR}/backup/hosted_${1}"
							break;;
				2)			add_hosted_list $1
							break;;
				3)			export edited_${1}=
							[ "$1" = "whitelist" ] && elsum=1
							[ "$1" = "blacklist" ] && elsum=2
							[ "$1" = "wc_blacklist" ] && elsum=4
							edit_list process $elsum hosted
							break;;
				[$noad])	print_red_line
							echo " whitelisted domain(s) removed from the $1:${RED}"
							column "${DIVERSION_DIR}/list/${1}.removed"
							echo "${NC}"
							press_enter_to return
							print_red_line;el_function
							break;;
				[Ee])		print_red_line;el_function;break;;
				*)			printf "\\n input is not an option\\n";;
			esac
		done
	fi

	case "$1" in
		whitelist)		hostedWL=$hostedList
						hostedWLUrl=$hostetURL;;
		blacklist)		hostedBL=$hostedList
						hostedBLUrl=$hostetURL
						[ "$ubl" = 1 ] && ubl=0;;
		wc_blacklist)	hostedWCBL=$hostedList
						hostedWCBLUrl=$hostetURL
						[ "$ubl" = 1 ] && ubl=0;;
	esac

	write_conf_file
	if [ "$ubl" = 1 ]; then
		update_blockinglist
		lastAction=" disabled and processed hosted $1,\\n updating blocking list"
	elif [ "$ubl" = 0 ]; then
		restart_DNSMASQ
		edited_blacklist=
		edited_wc_blacklist=
		write_conf_file
		lastAction=" disabled and processed hosted $1"
	fi
	if [ "$ubl" ]; then
		ubl=
		reload_menu
	fi
	print_red_line;el_function
}

get_hosted_list(){
	curl_dl(){ /usr/sbin/curl --insecure --location --connect-timeout 10 --retry 3 -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0" --progress-bar "$@";}

	delete_tmp_files(){
		rm -f "${DIVERSION_DIR}/list/$1.new"
		rm -f "${DIVERSION_DIR}/list/$1.tmp"
	}
	delete_tmp_files $2

	if [ "$sprl" = 1 ]; then
		echo
	else
		print_red_line
	fi
	echo " getting hosted $2"
	echo " $1"

	curl_dl "$1" >"${DIVERSION_DIR}/list/$2.new"
	trim_file "${DIVERSION_DIR}/list/$2.new"

	if [ -s "${DIVERSION_DIR}/list/$2.new" ]; then
		dos2unix "${DIVERSION_DIR}/list/$2.new" || true
		if [ "$2" = "blacklist" ]; then
			grep "^[^#]" "${DIVERSION_DIR}/list/$2.new" \
			| awk '!/ [0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*$|\*/' \
			| sort -u > "${DIVERSION_DIR}/list/$2.tmp"
			convert_to_ip $blockingIP "${DIVERSION_DIR}/list/$2.tmp"

			if [ -s "${DIVERSION_DIR}/list/$2.tmp" ] && grep -q "^$blockingIP" "${DIVERSION_DIR}/list/$2.tmp"; then
				if [ "$(wc -l < ${DIVERSION_DIR}/list/$2.tmp)" -gt "4000" ]; then
					echo
					echo " ${ERR} hosted $2 is above the limit of 4000 domains."
					echo " Consider to use a larger blocking list in ${RED_BG} b ${NC}"
					echo " to not have to $2 so many domains."
					echo
					echo " Keeping existing $2"
					logger -t Diversion "hosted $2 is above the limit of 4000 domains, keeping existing $2"
					delete_tmp_files $2
					press_enter_to acknowledge
					print_red_line;el_function
				else
					mv "${DIVERSION_DIR}/list/$2.tmp" "${DIVERSION_DIR}/list/$2"
					echo " download hosted $2 done"
				fi
			else
				echo
				echo " ${ERR} hosted $2 unsupported formatting"
				echo " or empty file, keeping existing $2"
				logger -t Diversion "hosted $2 unsupported formatting, keeping existing $2"
				delete_tmp_files $2
				press_enter_to acknowledge
				print_red_line;el_function
			fi
		else
			grep "^[^#]" "${DIVERSION_DIR}/list/$2.new" \
			| awk '!/[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]* |\*/' \
			| sort -u > "${DIVERSION_DIR}/list/$2.tmp"

			if [ -s "${DIVERSION_DIR}/list/$2.tmp" ]; then
				domaintest=$(grep -m1 "" "${DIVERSION_DIR}/list/$2.tmp")
				if [ "$(expr index "$domaintest" .)" -eq "0" ]; then
					echo " hosted $2 contains no domains, keeping existing $2"
					logger -t Diversion "hosted $2 contains no domains, keeping existing $2"
					delete_tmp_files $2
					press_enter_to acknowledge
					print_red_line;el_function
				elif [ "$(wc -l < ${DIVERSION_DIR}/list/$2.tmp)" -gt "4000" ]; then
					echo
					echo " ${ERR} hosted $2 is above the limit of 4000 domains."
					if [ "$2" = "whitelist" ]; then
						echo " Consider to use a smaller blocking list in ${RED_BG} b ${NC}"
						echo " to not have to $2 so many domains."
						echo
						echo " Keeping existing $2"
					else
						echo " Consider to use a larger blocking list in ${RED_BG} b ${NC}"
						echo " to not have to $2 so many domains."
						echo
						echo " Keeping existing $2"
					fi
					logger -t Diversion "hosted $2 is above the limit of 4000 domains, keeping existing $2"
					delete_tmp_files $2
					press_enter_to acknowledge
					print_red_line;el_function
				else
					mv "${DIVERSION_DIR}/list/$2.tmp" "${DIVERSION_DIR}/list/$2"
					echo " download hosted $2 done"
				fi
			else
				echo
				echo " ${ERR} hosted $2 unsupported formatting"
				echo " or empty file, keeping existing $2"
				logger -t Diversion "hosted $2 unsupported formatting, keeping existing $2"
				delete_tmp_files $2
				press_enter_to acknowledge
				print_red_line;el_function
			fi
		fi
	else
		echo
		echo " ${ERR} hosted $2 download failed or"
		echo " empty file, keeping existing $2"
		logger -t Diversion "hosted $2 download failed or empty file, keeping existing $2"
		delete_tmp_files $2
		press_enter_to acknowledge
		print_red_line;el_function
	fi
	delete_tmp_files $2
}

process_hosted_lists(){
	if [ "$hostedWL" = "on" ] || [ "$hostedBL" = "on" ] || [ "$hostedWCBL" = "on" ]; then
		[ "$hostedWL" = "on" ] && get_hosted_list $hostedWLUrl whitelist >/dev/null 2>&1
		[ "$hostedBL" = "on" ] && get_hosted_list $hostedBLUrl blacklist >/dev/null 2>&1
		[ "$hostedWCBL" = "on" ] && get_hosted_list $hostedWCBLUrl wc_blacklist >/dev/null 2>&1
		edit_list process 7 sh >/dev/null 2>&1
		lastAction=" Updated and processed all hosted lists"
	else
		lastAction=" No hosted lists are enabled"
	fi
	echo "$lastAction"
	exit 0
}

check_no_space(){
	printf "\\n${RED_BG} Enter $noSpaceTerm ${NC} [e=Exit] ";read -r listadd
	if [ "$stripUrl" = "1" ]; then
		listadd=$(echo $listadd | sed 's#http[s]*://##;s#/.*##')
	fi
	# check for space in name
	case "$listadd" in
		 [Ee])	echo;$returnTo;;
		*\ * ) 	echo;echo "${RED} $noSpaceTerm has space in name, this cannot work${NC}"
				check_no_space;;
		 *\**) 	echo;echo "${RED} $noSpaceTerm has star (*) in name, this cannot work${NC}"
				check_no_space;;
	esac
	if [ "$noSpaceTerm" = "domain" ]; then
		if echo $listadd | grep "0\.0\.0\.0" >/dev/null || echo $listadd | grep "$blockingIP" >/dev/null; then
			echo;echo "${RED} $noSpaceTerm contains blocking IP,"
			echo " no need to add it${NC}"
			check_no_space
		fi
		if [ "$(expr index "$listadd" .)" -eq "0" ]; then
			if [ "$(echo $returnTo | awk '{print $3}')" = "whitelist" ]; then
				echo;echo "${RED} $listadd${NC} is not a proper domain name."
				echo " But you may use it for a near match(es) search."
				while true; do
					printf "\\n Continue? [1=Yes 2=No] ";read -r continue
					case "$continue" in
						1)	if [ -z "$domainsPerLine" ] || [ "$domainsPerLine" != 1 ]; then
								print_red_line
								printf "${INFO} For near match(es) search to work, set the\\n${SPACE} Domains per line setting in ${RED_BG} b ${NC} to ${GREEN}1${NC}\\n"
								press_enter_to return
								$returnTo
							else
								addToList=0
							fi
							break;;
						2)	echo;$returnTo;break;;
						*)	printf "\\n input is not an option\\n\\n";;
					esac
				done
			else
				echo;echo "${RED} $listadd${NC} is not a proper domain name"
				echo " and cannot be added."
				check_no_space
			fi
		fi
	fi
}

sort_list(){
	cp "${DIVERSION_DIR}/list/$2" "${DIVERSION_DIR}/backup/${todayHour}-$2"

	trim_file "${DIVERSION_DIR}/list/$2"

	if [ "$2" = "blacklist" ]; then
		grep "^[^#]" "${DIVERSION_DIR}/list/$2" \
		| awk '!/ [0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*$|\*/' \
		| sort -u > "${DIVERSION_DIR}/list/$2.tmp"
		grep '^#!' "${DIVERSION_DIR}/list/$2" | sort -u >> "${DIVERSION_DIR}/list/$2.tmp"
		convert_to_ip $blockingIP "${DIVERSION_DIR}/list/$2.tmp"
	else
		grep "^[^#]" "${DIVERSION_DIR}/list/$2" \
		| awk '!/[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]* |\*/' \
		| sort -u > "${DIVERSION_DIR}/list/$2.tmp"
		grep '^#!' "${DIVERSION_DIR}/list/$2" | sort -u >> "${DIVERSION_DIR}/list/$2.tmp"
	fi

	if [ ! -s "${DIVERSION_DIR}/list/$2.tmp" ]; then
		printf '\n' >>"${DIVERSION_DIR}/list/$2.tmp"
	fi

	mv "${DIVERSION_DIR}/list/$2.tmp" "${DIVERSION_DIR}/list/$2"
}

convert_to_ip(){ sed -i "s/^[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}/$1/g" "$2";}

# aka THE MONSTER
edit_list(){
	if [ "$1" = "edit" ]; then

		if [ ! -f "${DIVERSION_DIR}/list/$2" ]; then
			printf "\\n${RED} Notice:${NC} Empty or no $2 found\\n restoring from backup...\\n\\n"
			restore_file $2

			press_enter_to continue
			edit_list edit $2
		elif [ ! -s "${DIVERSION_DIR}/backup/$todayHour-$2" ]; then
				cp "${DIVERSION_DIR}/list/$2" "${DIVERSION_DIR}/backup/$todayHour-$2"
		fi

		trim_file "${DIVERSION_DIR}/list/$2"
		# convert IP, just to be sure
		if [ "$2" = "blacklist" ]; then
			convert_to_ip $blockingIP "${DIVERSION_DIR}/list/$2"
		fi
		print_red_line
		lineNumbers=$(wc -l < ${DIVERSION_DIR}/list/$2)
		[ "$editorColor" = "off" ] && printf " Your $2 has these $lineNumbers entries:\\n\\n" || printf " Your${GREEN} $2${NC} has these ${GREEN}$lineNumbers${NC} entries:\\n\\n"

		paginate_list(){
			i=$1

			if [ "$editorPaginate" != "off" ] && [ "$lineNumbers" -ge "1" ]; then
				[ "$((lineNumbers-$3))" -le "10" ] && endNumber=$lineNumbers || endNumber=$3 #set end number for first run
			else
				endNumber=$lineNumbers
			fi

			tail -n +$1 "${DIVERSION_DIR}/list/$2" | head -n $((endNumber-$1+1)) | while IFS= read -r line; do

				if [ "$editorColor" = "off" ]; then
					echo " $i: $line"
					[ "$editorPaginate" != "off" ] && [ "$lineNumbers" -ge "1" ] && echo "lineCount=$i" >/tmp/divfile_lists # preserve lineCount from subshell
					i=$((i+1))

				else
					if echo "$line" | grep -q "^# "; then
						echo " $i: $line"
					elif echo "$line" | grep -q "^#! "; then
						[ "$2" = "whitelist" ] || [ "$2" = "wc_blacklist" ] && echo " $i: #! ${RED}$(echo "$line" | awk '{print $2}')${NC}$(echo "$line" | awk '{$1=$2=""}1' | sed -e 's/ //')"
						[ "$2" = "blacklist" ] && echo " $i: #! $(echo "$line" | awk '{print $2}') ${RED}$(echo "$line" | awk '{print $3}')${NC}$(echo "$line" | awk '{$1=$2=$3=""}1' | sed -e 's/  //')"
					else
						[ "$2" = "whitelist" ] || [ "$2" = "wc_blacklist" ] && echo " $i: ${GREEN}$(echo "$line" | awk '{print $1}')${NC}$(echo "$line" | awk '{$1=""}1')"
						[ "$2" = "blacklist" ] && echo " $i: $(echo "$line" | awk '{print $1}') ${GREEN}$(echo "$line" | awk '{print $2}')${NC}$(echo "$line" | awk '{$1=$2=""}1' | sed -e 's/ //')"
					fi
					[ "$editorPaginate" != "off" ] && [ "$lineNumbers" -ge "1" ] && echo "lineCount=$i" >/tmp/divfile_lists # preserve lineCount from subshell
					i=$((i+1))
				fi
			done

			if [ "$editorPaginate" != "off" ] && [ "$lineNumbers" -ge "1" ]; then
				. /tmp/divfile_lists
				end=$((lineCount+editorPaginate))
				[ "$((lineNumbers-lineCount))" -le "$editorPaginate" ] && next=$((lineNumbers-lineCount)) || next=$editorPaginate
				[ "$((lineNumbers-end))" -le "10" ] && end=$lineNumbers next=$((lineNumbers-lineCount)) #set end number for subsequent run
			else
				lineCount=$lineNumbers
			fi

			if [ "$lineCount" -ge "$lineNumbers" ]; then
				return
			else
				printf "\\n 1. Next $next of remaining $((lineNumbers-lineCount)) lines, $lineNumbers total\\n 2. Show $2 options\\n"
				while true; do
					printf "\\n Enter selection [1-2 e=Exit] ";read -r confirm
					case "$confirm" in
						1)	echo;paginate_list $((lineCount+1)) $2 $end;break;;
						2)	break;;
					 [Ee])	print_red_line;el_function;break;;
						*)	printf "\\n input is not an option\\n";;
					esac
				done
			fi

		}
		# paginate_list params: startline ...list pagination
		paginate_list 1 $2 $editorPaginate
		[ "$editorPaginate" != "off" ] && rm -f /tmp/divfile_lists

		print_red_line
		noad=; hopt=7
		printf " 1. Add domain\\n 2. Delete domain\\n 3. Process $2\\n"
		printf " 4. Sort and verify $2\\n 5. Restore $2 from backup\\n"
		if [ "$editorColor" = "on" ]; then
			echo " 6. Set domain${GREEN} active${NC} / ${RED}inactive${NC} (#! )"
		else
			echo " 6. Set domain active / inactive (#! )"
		fi
		echo " 7. Use hosted $2"
		if [ -s "${DIVERSION_DIR}/list/${2}.removed" ]; then
			noad=8; hopt=8
			printf " 8. View auto-removed whitelisted domains (${RED}$(wc -l < ${DIVERSION_DIR}/list/${2}.removed)${NC})\\n"
		fi

		while true; do
			printf "\\n Enter selection [1-$hopt e=Exit] ";read -r continue
			case "$continue" in
				1)	print_red_line
					[ "$2" = "blacklist" ] || [ "$2" = "whitelist" ] && likeso="or www.domain.com" || likeso=
					echo " Add domain like so: domain.com $likeso"
					if [ "$2" = "blacklist" ]; then
						if [ "$(nvram get ipv6_service)" != "disabled" ]; then
							v6Add=" and ::"
						else
							v6Add=
						fi
						echo "${GREEN} blocking address ($blockingIP$v6Add) is auto-added${NC}"
					fi
					[ "$2" = "whitelist" ] && [ "$editorAutowww" = "on" ] && echo "${GREEN} The www.domain.com or domain.com is auto-added${NC}"
					echo
					echo " An explanatory comment can be added after this step"

					addToList=1
					noSpaceTerm=domain
					stripUrl=1
					returnTo="edit_list edit $2"
					check_no_space
					greplistadd=$(echo $listadd | sed -e 's/\./\\./g')
					print_red_line

					while true; do
						case "$listadd" in
							[Ee])	edit_list edit $2;break;;
							   *)	forceadd=0;process_near=
									forced='#(forced-entry)'

							if [ "$2" = "blacklist" ]; then
								rmInOl=
								greplst=$(grep " $greplistadd$\| $greplistadd " "${DIVERSION_DIR}/list/$2")
								if [ "$greplst" ]; then
									printf "${GREEN}$(echo "$greplst" | awk '{printf " %s\n",$0}')${NC}\\n\\n is already in blacklist\\n"
									press_enter_to return
									edit_list edit $2
								elif grep -q "^$greplistadd$\|^$greplistadd " "${DIVERSION_DIR}/list/whitelist" "${DIVERSION_DIR}/list/wc_blacklist"; then
									if grep -q "^$greplistadd$\|^$greplistadd " "${DIVERSION_DIR}/list/whitelist"; then
										echo " found exact match in the ${GREEN}whitelist${NC}"
									fi
									if grep -q "^$greplistadd$\|^$greplistadd " "${DIVERSION_DIR}/list/wc_blacklist"; then
										echo " found exact match in the ${GREEN}wildcard-blacklist${NC}"
									fi
									rmInOl=1
									echo
									echo "$ATTN above match(es) will be removed when added"
									echo "$SPACE to the blacklist"
									echo
								fi

								[ "$bfFs" = "on" ] && ptext=" primary" || ptext=
								grepbf=$(grep -o " $greplistadd \| $greplistadd$" "${DIVERSION_DIR}/list/blockinglist")
								if [ "$grepbf" ]; then
									echo " found exact match in$ptext blocking list ${GREEN}$bfType${NC}"
									forceadd=1
								fi
								if [ "$bfFs" = "on" ]; then
									grepbf=$(grep -o " $greplistadd \| $greplistadd$" "${DIVERSION_DIR}/list/blockinglist_fs")
									if [ "$grepbfs" ]; then
										echo " found exact match in secondary blocking list ${GREEN}$bfTypeFs${NC}"
										forceadd=1
										echo
									fi
								fi

								if [ "$forceadd" = "0" ]; then
									printf "${GREEN} $listadd${NC}\\n was not found in blocking list(s)\\n"
									adtbl=?
								else
									echo " for ${GREEN}$listadd${NC}"
									echo
									printf " If you add it anyway, it may have no effect unless\\n you select a smaller blocking list.\\n"
									printf "\\n The domain will be marked #(forced-entry).\\n"
									adtbl=" anyway?"
								fi

								while true; do
									printf "\\n Add it to blacklist$adtbl [1=Yes 2=No] ";read -r continue
									case "$continue" in
										1)	while true; do
												printf "\\n Do you want to add a comment? [1=Yes 2=No] ";read -r continueC
												case "$continueC" in
													1)	print_red_line
														echo " An explanatory comment will look like so:"
														echo " $blockingIP www.domain.com # ${GREEN}this comment explains why you are adding this domain${NC}"
														printf "${GREEN}\\n The \"${NC}#${GREEN}\" is auto-added${NC}\\n"
														printf "\\n${RED_BG} Enter comment ${NC} [e=Exit] ";read -r listcomment
														case "$listcomment" in
															e)	edit_list edit $2;break;;
															*)	printf "\\n${GREEN} $listadd${NC} # $listcomment \\n added to $2\\n\\n"
																comment=" # $listcomment"
																[ "$forceadd" = "1" ] && echo $blockingIP $listadd $comment $forced >>"${DIVERSION_DIR}/list/$2"
																[ "$forceadd" = "0" ] && echo $blockingIP $listadd $comment >>"${DIVERSION_DIR}/list/$2"
																if [ "$(nvram get ipv6_service)" != "disabled" ]; then
																	[ "$forceadd" = "1" ] && echo :: $listadd $comment $forced >>"${DIVERSION_DIR}/list/$2"
																	[ "$forceadd" = "0" ] && echo :: $listadd $comment >>"${DIVERSION_DIR}/list/$2"
																fi;;
														esac
														break;;
													2)	printf "\\n${GREEN} $listadd${NC}\\n added to $2\\n\\n"
														[ "$forceadd" = "1" ] && echo $blockingIP $listadd $forced >>"${DIVERSION_DIR}/list/$2"
														[ "$forceadd" = "0" ] && echo $blockingIP $listadd >>"${DIVERSION_DIR}/list/$2"
														if [ "$(nvram get ipv6_service)" != "disabled" ]; then
															[ "$forceadd" = "1" ] && echo :: $listadd $forced >>"${DIVERSION_DIR}/list/$2"
															[ "$forceadd" = "0" ] && echo :: $listadd >>"${DIVERSION_DIR}/list/$2"
														fi
														break;;
													*) 	printf "\\n input is not an option\\n";;
												esac
											done

											if [ "$rmInOl" = "1" ]; then
												sed -i "/^$greplistadd\b/d" "${DIVERSION_DIR}/list/whitelist" "${DIVERSION_DIR}/list/wc_blacklist"
											fi

											export edited_${2}=1
											logger -t Diversion "added '$listadd' to $2 (user action)";break;;
										2)	edit_list edit $2;break;;
										*) 	printf "\\n input is not an option\\n";;
									esac
								done

							elif [ "$2" = "wc_blacklist" ]; then
								rmInOl=
								greplst=$(grep "^$greplistadd$\|^$greplistadd \| $greplistadd$\| $greplistadd " "${DIVERSION_DIR}/list/$2")
								if [ "$greplst" ]; then
									printf "${GREEN}$(echo "$greplst" | awk '{printf " %s\n",$0}')${NC}\\n\\n is already in wildcard-blacklist\\n"
									press_enter_to return
									edit_list edit $2
								elif grep -q "^$greplistadd$\|^$greplistadd \| $greplistadd$\| $greplistadd " "${DIVERSION_DIR}/list/whitelist" "${DIVERSION_DIR}/list/blacklist"; then
									if grep -q "^$greplistadd$\|^$greplistadd " "${DIVERSION_DIR}/list/whitelist"; then
										echo " found exact match in the ${GREEN}whitelist${NC}"
									fi
									if grep -q " $greplistadd$\| $greplistadd " "${DIVERSION_DIR}/list/blacklist"; then
										echo " found exact match in the ${GREEN}blacklist${NC}"
									fi
									rmInOl=1
									echo
									echo "$ATTN above match(es) will be removed when added"
									echo "$SPACE to the wildcard-blacklist"
									echo
								fi

								[ "$bfFs" = "on" ] && ptext=" primary" || ptext=
								grepbf=$(grep -o " $greplistadd \| $greplistadd$" "${DIVERSION_DIR}/list/blockinglist")
								if [ "$grepbf" ]; then
									echo " found exact match in$ptext blocking list ${GREEN}$bfType${NC}"
									forceadd=1
								fi
								if [ "$bfFs" = "on" ]; then
									grepbf=$(grep -o " $greplistadd \| $greplistadd$" "${DIVERSION_DIR}/list/blockinglist_fs")
									if [ "$grepbfs" ]; then
										echo " found exact match in secondary blocking list ${GREEN}$bfTypeFs${NC}"
										forceadd=1
										echo
									fi
								fi

								if [ "$forceadd" = "0" ]; then
									printf "${GREEN} $listadd${NC}\\n was not found in blocking list(s)\\n"
									adtbl=?
								else
									echo " for ${GREEN}$listadd${NC}"
									echo
									printf " If you add it anyway, it may have no effect unless\\n you select a smaller blocking list.\\n"
									printf "\\n The domain will be marked #(forced-entry).\\n"
									adtbl=" anyway?"
								fi

								while true; do
									printf "\\n Add it to wildcard-blacklist$adtbl [1=Yes 2=No] ";read -r continue
									case "$continue" in
										1)	while true; do
												printf "\\n Do you want to add a comment? [1=Yes 2=No] ";read -r continueC
												case "$continueC" in
													1)	print_red_line
														echo " An explanatory comment will look like so:"
														echo " www.domain.com # ${GREEN}this comment explains why you are adding this domain${NC}"
														printf "${GREEN}\\n The \"${NC}#${GREEN}\" is auto-added${NC}\\n"
														printf "\\n${RED_BG} Enter comment ${NC} [e=Exit] ";read -r listcomment
														case "$listcomment" in
															e)	edit_list edit $2;break;;
															*)	printf "\\n${GREEN} $listadd${NC} # $listcomment \\n added to $2\\n\\n"
																comment=" # $listcomment"
																[ "$forceadd" = "1" ] && echo $listadd $comment $forced >>"${DIVERSION_DIR}/list/$2"
																[ "$forceadd" = "0" ] && echo $listadd $comment >>"${DIVERSION_DIR}/list/$2"
																;;
														esac
														break;;
													2)	printf "\\n${GREEN} $listadd${NC}\\n added to $2\\n\\n"
														[ "$forceadd" = "1" ] && echo $listadd $forced >>"${DIVERSION_DIR}/list/$2"
														[ "$forceadd" = "0" ] && echo $listadd >>"${DIVERSION_DIR}/list/$2"
														break;;
													*) 	printf "\\n input is not an option\\n";;
												esac
											done

											if [ "$rmInOl" = "1" ]; then
												sed -i "/^$greplistadd\b/d" "${DIVERSION_DIR}/list/whitelist"
												sed -i "/ $greplistadd\b/d" "${DIVERSION_DIR}/list/blacklist"
											fi

											export edited_${2}=1
											logger -t Diversion "added '$listadd' to $2 (user action)";break;;
										2)	edit_list edit $2;break;;
										*) 	printf "\\n input is not an option\\n";;
									esac
								done

							elif [ "$2" = "whitelist" ]; then
								rmInOl=
								greplst=$(grep "^$greplistadd$\|^$greplistadd \|\#! $greplistadd" "${DIVERSION_DIR}/list/$2")
								if [ "$greplst" ]; then
									printf "${GREEN}$(echo "$greplst" | awk '{printf " %s\n",$0}')${NC}\\n\\n is already in whitelist\\n"
									press_enter_to return
									edit_list edit $2
								elif grep -q "^$greplistadd$\| $greplistadd$\| $greplistadd \|^$greplistadd " "${DIVERSION_DIR}/list/blacklist" "${DIVERSION_DIR}/list/wc_blacklist"; then
									if grep -q " $greplistadd$\| $greplistadd " "${DIVERSION_DIR}/list/blacklist"; then
										echo " found exact match in the ${GREEN}blacklist${NC}"
									fi
									if grep -q "^$greplistadd$\|^$greplistadd " "${DIVERSION_DIR}/list/wc_blacklist"; then
										echo " found exact match in the ${GREEN}wildcard-blacklist${NC}"
									fi
									rmInOl=1
									echo
									echo "$ATTN above match(es) will be removed when added"
									echo "$SPACE to the whitelist"
									echo
								fi

								[ "$bfFs" = "on" ] && ptext=" primary" || ptext=

								if [ "$addToList" = "1" ]; then
									grepbf=$(grep -o " $greplistadd \| $greplistadd$" "${DIVERSION_DIR}/list/blockinglist")
									if [ "$grepbf" ]; then
										echo " found exact match in$ptext blocking list ${GREEN}$bfType${NC}"
									fi
									if [ "$bfFs" = "on" ]; then
										grepbfs=$(grep -o " $greplistadd \| $greplistadd$" "${DIVERSION_DIR}/list/blockinglist_fs")
										if [ "$grepbfs" ]; then
											echo " found exact match in secondary blocking list ${GREEN}$bfTypeFs${NC}"
											echo
										fi
									fi
								else
									printf " looking for near match(es) of:\\n ${GREEN}$listadd${NC}\\n"
								fi

								nearmatches=;matchlist=;matchlist_fs=;ask=

								if [ "$grepbf" ] || [ "$grepbfs" ] || [ "$rmInOl" = "1" ]; then
									echo " for ${GREEN}$listadd${NC}"
									echo
									while true; do
										printf " Add it to whitelist? [1=Yes 2=No] ";read -r continue
										case "$continue" in
											1) ask=1;break;;
											2) edit_list edit $2;break;;
											*) printf "\\n input is not an option\\n";;
										esac
									done
								else
									forceadd=1
									[ "$addToList" = "1" ] && printf " ${GREEN}$listadd${NC}\\n was not found in blocking list(s), looking for\\n near match(es):\\n"
									echo
									if grep -q $greplistadd "${DIVERSION_DIR}/list/blockinglist"; then
										printf " near match(es) in$ptext blocking list ${GREEN}$bfType${NC}\\n"
										matchlist=$(grep $greplistadd "${DIVERSION_DIR}/list/blockinglist" | sed -e "s/^$blockingIP//")
										echo "${GREEN}$matchlist${NC}"
										echo
										nearmatches=1
									else
										echo " none found in$ptext blocking list ${GREEN}$bfType${NC}"
									fi
									if [ "$bfFs" = "on" ] && grep -q $greplistadd "${DIVERSION_DIR}/list/blockinglist_fs"; then
										printf " near match(es) in secondary blocking list ${GREEN}$bfTypeFs${NC}\\n"
										matchlist_fs=$(grep $greplistadd "${DIVERSION_DIR}/list/blockinglist_fs" | sed -e "s/^$blockingIP//")
										printf "${GREEN}$matchlist_fs${NC}\\n"
										nearmatches=1
									else
										echo " none found in secondary blocking list ${GREEN}$bfTypeFs${NC}"
									fi
								fi

								if [ "$nearmatches" ]; then
									while true; do
										printf "\\n Add near match(es) to whitelist? [1=Yes 2=No] ";read -r continue
										case "$continue" in
											1) 	process_near=1;break;;
											2) 	process_near=0;break;;
											*)	printf "\\n input is not an option\\n";;
										esac
									done
								fi

								if [ "$forceadd" = "1" ] && [ "$addToList" = "1" ]; then
									print_red_line
									printf "${GREEN} $listadd${NC}\\n was not found in blocking list(s)\\n"
									printf "\\n If you add it anyway, it may have no effect unless\\n you select a larger blocking list.\\n"
									printf "\\n The domain will be marked #(forced-entry) and is\\n not re-added to the blocking list if you remove it.\\n"
									while true; do
										printf "\\n Add it to whitelist anyway? [1=Yes 2=No] ";read -r continue
										case "$continue" in
											1) process_force=1;ask=1;break;;
											2) process_force=;break;;
											*)	printf "\\n input is not an option\\n";;
										esac
									done
								fi

								if [ "$process_near" = "1" ] || [ "$ask" = "1" ]; then
									while true; do
										printf "\\n Do you want to add a comment? [1=Yes 2=No] ";read -r continue
										case "$continue" in
											1)	print_red_line
												echo " An explanatory comment will look like so:"
												echo " www.domain.com # ${GREEN}this comment explains why you are adding this domain${NC}"
												printf "${GREEN}\\n The \"${NC}#${GREEN}\" is auto-added${NC}\\n"
												printf "\\n${RED_BG} Enter comment ${NC} [e=Exit] ";read -r listcomment
												case "$listcomment" in
													e)	edit_list edit $2;break;;
													*)	comment=" # $listcomment";;
												esac
												break;;
											2)	comment=;break;;
											*)	printf "\\n input is not an option\\n";;
										esac
									done
								fi

								if [ "$forceadd" = "0" ] && [ "$addToList" = "1" ]; then
									if [ "$editorAutowww" = "on" ]; then
										case $listadd in
											  www.*) 	echo $listadd $comment >>"${DIVERSION_DIR}/list/$2"
														if ! grep -q "^${greplistadd##www.}" "${DIVERSION_DIR}/list/$2"; then
															echo ${listadd##www.} $comment >>"${DIVERSION_DIR}/list/$2"
														fi
														printf "\\n${GREEN} $listadd${NC},${GREEN} ${listadd##www.} $comment${NC}\\n added to $2\\n\\n"
														;;
											  *) 		echo $listadd $comment >>"${DIVERSION_DIR}/list/$2"
														if ! grep -q "^www.$greplistadd" "${DIVERSION_DIR}/list/$2"; then
															echo www.$listadd $comment >>"${DIVERSION_DIR}/list/$2"
														fi
														printf "\\n${GREEN} $listadd${NC},${GREEN} www.$listadd${NC} $comment\\n added to $2\\n"
														;;
										esac
									else
										printf "\\n${GREEN} $listadd${NC} # $comment\\n added to $2\\n\\n"
										echo $listadd $comment >>"${DIVERSION_DIR}/list/$2"
									fi
								fi

								if [ "$forceadd" = "1" ] && [ "$process_force" = "1" ]; then
									if [ "$editorAutowww" = "on" ]; then
										case $listadd in
											  www.*) 	echo $listadd $comment $forced >>"${DIVERSION_DIR}/list/$2"
														if ! grep -q "^${greplistadd##www.}" "${DIVERSION_DIR}/list/$2"; then
															echo ${listadd##www.} $comment $forced >>"${DIVERSION_DIR}/list/$2"
														fi
														printf "\\n${GREEN} $listadd${NC},${GREEN} ${listadd##www.}${NC} $comment $forced\\n added to $2\\n"
														;;
											  *) 		echo $listadd $comment $forced >>"${DIVERSION_DIR}/list/$2"
														if ! grep -q "^www.$greplistadd" "${DIVERSION_DIR}/list/$2"; then
															echo www.$listadd $comment $forced >>"${DIVERSION_DIR}/list/$2"
														fi
														printf "\\n${GREEN} $listadd${NC},${GREEN} www.$listadd${NC} $comment $forced\\n added to $2\\n"
														;;
										esac
									else
										printf "\\n${GREEN} $listadd${NC} $comment $forced\\n added to $2\\n\\n"
										echo $listadd $comment $forced >>"${DIVERSION_DIR}/list/$2"
									fi
								fi

								if [ "$forceadd" = "1" ] && [ "$process_near" = "1" ]; then
									echo
									if [ "$editorAutowww" = "on" ]; then
										for entry in $(echo "$matchlist$matchlist_fs" | tr " " "\n" | sort -u | tr "\n" " "); do
											grepentry=$(echo $entry | sed -e 's/\./\\./g')
											case $entry in
												  www.*) 	if ! grep -q "^$grepentry" "${DIVERSION_DIR}/list/$2"; then
																echo $entry $comment >>"${DIVERSION_DIR}/list/$2"
															fi
															if ! grep -q "^${grepentry##www.}" "${DIVERSION_DIR}/list/$2"; then
																echo ${entry##www.}$comment >>"${DIVERSION_DIR}/list/$2"
															fi
															printf "${GREEN} $entry${NC},${GREEN} ${entry##www.}${NC}\\n"
															logger -t Diversion "added '$entry, ${entry##www.}' to $2 (user action)"
															;;
												  *) 		if ! grep -q "^www.$grepentry" "${DIVERSION_DIR}/list/$2"; then
																echo www.$entry $comment >>"${DIVERSION_DIR}/list/$2"
															fi
															if ! grep -q "^$grepentry" "${DIVERSION_DIR}/list/$2"; then
																echo $entry $comment >>"${DIVERSION_DIR}/list/$2"
															fi
															printf "${GREEN} $entry${NC},${GREEN} www.$entry${NC}\\n"
															logger -t Diversion "added '$entry, www.$entry' to $2 (user action)"
															;;
											esac
										done
									else
										for entry in $(echo "$matchlist$matchlist_fs" | tr " " "\n" | sort -u | tr "\n" " "); do
											echo $entry $comment >>"${DIVERSION_DIR}/list/$2"
											logger -t Diversion "added '$entry' to $2 (user action)"
											printf "${GREEN} $entry${NC} $comment\\n"
										done
									fi
									printf " added to $2\\n\\n"
								fi

								if [ "$rmInOl" = "1" ]; then
									sed -i "/ $greplistadd\b/d" "${DIVERSION_DIR}/list/blacklist"
									sed -i "/^$greplistadd\b/d" "${DIVERSION_DIR}/list/wc_blacklist"
								fi

								export edited_${2}=1
								[ "$addToList" = "1" ] && logger -t Diversion "added '$listadd' to $2 (user action)"
							fi
							edit_list edit $2;break;;
						esac
					done
					edit_list edit $2;break;;
				2)	lineNumbers=$(wc -l < ${DIVERSION_DIR}/list/$2)
					print_red_line
					[ "$2" = "whitelist" ] && printf "\\n deleted domains are re-added to blocking list(s)\\n unless marked as inactive or #(forced-entry).\\n"
					while true; do
						printf "\\n${RED_BG} Line number(s) to delete (#, #-#)${NC} [e=Exit] ";read -r deleteline
						case "$deleteline" in
							[Ee])   edit_list edit $2;break;;
							*)		echo "$deleteline" | egrep -q '^[[:digit:]-]*$'
									if [ "$?" -ne "0" ]; then
									   printf "\\n input is not a number.\\n"
									else
										delete_range_start=$(echo $deleteline | awk -F "-" '{print $1}')
										delete_range_end=$(echo $deleteline | awk -F "-" '{print $2}')
										[ "$delete_range_end" = "" ] && delete_range_end=$delete_range_start

										if [ "$delete_range_end" -lt "$delete_range_start" ]; then
											printf "\\n upper range must be higher than lower range.\\n"
										else
											if [ "$delete_range_end" = "$delete_range_start" ]; then
												delete_range_end=$delete_range_start
											elif [ "$delete_range_end" -gt "$lineNumbers" ]; then
												printf "\\n${RED_BG} Setting range to last entry${NC} (line: $lineNumbers)\\n"
											fi
											break
										fi
									fi;;
						esac
					done

					deleteline=$delete_range_start
					deleteloop=$((delete_range_end-delete_range_start+1))

					i=1
					while [ "$i" -le "$deleteloop" ]; do
							readd=$(sed -n "${deleteline}p" ${DIVERSION_DIR}/list/$2)
							readd=$(echo $readd | sed "s/#!//g; s/$blockingIP//g" | awk '{print $1}')
							loggerAdd=
							if [ "$2" = "whitelist" ]; then
									if echo "$(sed -n "${deleteline}p" ${DIVERSION_DIR}/list/$2)" | grep -q '#!\|(forced-entry)'; then
										loggerAdd=", inactive or (forced-entry) found, not re-added to blocking list(s)"
									else
										echo $blockingIP $readd >>"${DIVERSION_DIR}/list/blockinglist"
										if [ "$(nvram get ipv6_service)" != "disabled" ]; then
											echo :: $readd >>"${DIVERSION_DIR}/list/blockinglist"
										fi
										if [ "$bfFs" = "on" ]; then
											echo $blockingIP $readd >>"${DIVERSION_DIR}/list/blockinglist_fs"
											if [ "$(nvram get ipv6_service)" != "disabled" ]; then
												echo :: $readd >>"${DIVERSION_DIR}/list/blockinglist_fs"
											fi
										fi
										loggerAdd=" and appended it to blocking list(s)"
									fi
							fi
							sed -i "${deleteline}d" "${DIVERSION_DIR}/list/$2"
							export edited_${2}=1
							logger -t Diversion "deleted '$readd' from $2$loggerAdd (user action)"
							i=$((i+1))
					done
					edit_list edit $2
					break;;
				3)	export edited_${2}=
					[ "$2" = "whitelist" ] && elsum=1
					[ "$2" = "blacklist" ] && elsum=2
					[ "$2" = "wc_blacklist" ] && elsum=4
					edit_list process $elsum
					break;;
				4)	print_red_line
					printf " This will sort the $2 file\\n alphanumerically, remove duplicates and entries\\n"
					printf " that don't work in $NAME.\\n"
					printf "\\n domain.com and www.domain.com will be sorted\\n separately.\\n"
					printf "\\n A backup of the file will be made in the\\n /backup/ directory.\\n"
					while true; do
						printf "\\n Sort the file now? [1=Yes e=Exit] ";read -r confirm
						case "$confirm" in
							1)	sort_list sort $2;break;;
						 [Ee])	break;;
							*)	printf "\\n input is not an option\\n";;
						esac
					done
					edit_list edit $2;break;;
				5)	restore_file $2
					press_enter_to continue
					edit_list edit $2;break;;
				6)	lineNumbers=$(wc -l < ${DIVERSION_DIR}/list/$2)
					print_red_line
					[ "$2" = "whitelist" ] && printf "\\n inactive domains are NOT re-added to blocking list(s)\\n"
					while true; do
						printf "\\n${RED_BG} Line number to set active / inactive ${NC} [e=Exit] ";read -r deleteline
						case "$deleteline" in
								[Ee])	edit_list edit $2;break;;
						 ''|*[!0-9]*)	printf "\\n input is not a number.\\n";;
					[1-9]|[1-9][0-9]*)	# add entry back to list, 1 - 999
										if [ "$deleteline" -gt "$lineNumbers" ]; then
											printf "\\n input is outside number range.\\n"
										else
											readd=$(sed -n "${deleteline}p" ${DIVERSION_DIR}/list/$2)
											readd=$(echo $readd | sed "s/#!//g; s/$blockingIP//g" | awk '{print $1}')
											while true; do
												if [ "$editorColor" = "on" ]; then
													printf "\\n Set domain [1=${GREEN}active${NC} 2=${RED}inactive${NC}] ";read -r continueC
												else
													printf "\\n Set domain [1=active 2=inactive] ";read -r continueC
												fi
												case "$continueC" in
													1)	# delete inactive mark if already there
														sed -i "${deleteline}s/#! //" "${DIVERSION_DIR}/list/$2"
														export edited_${2}=1
														logger -t Diversion "set '$readd' to active in $2 (user action)"
														edit_list edit $2;break;;
													2)	# delete inactive mark if already there
														sed -i "${deleteline}s/#! //" "${DIVERSION_DIR}/list/$2"
														sed -i "${deleteline}s/.*/#! &/" "${DIVERSION_DIR}/list/$2"
														export edited_${2}=1
														logger -t Diversion "set '$readd' to inactive in $2 (user action)"
														edit_list edit $2;break;;
													*) 	printf "\\n input is not an option\\n\\n";;
												esac
											done

											break
										fi;;
									*)	printf "\\n line number is a comment line.\\n";;
						esac
					done;break;;
				7)	hosted_lists $2
					print_red_line;el_function;break;;
			[$noad])print_red_line
					echo " whitelisted domain(s) removed from the $2:${RED}"
					column "${DIVERSION_DIR}/list/${2}.removed"
					echo "${NC}"
					press_enter_to return
					print_red_line;el_function
					break;;
			 [Ee])  print_red_line;el_function;break;;
				*)	printf "\\n input is not an option\\n";;
			esac
		done

	elif [ "$1" = "process" ]; then
		read_conf_file
		echo
		eleWL=
		if [ "$hostedWL" = "on" ] || [ "$hostedBL" = "on" ] || [ "$hostedWCBL" = "on" ]; then
			print_red_line
			sprl=1
			case "$2" in
				1	)	[ "$hostedWL" = "on" ] && get_hosted_list $hostedWLUrl whitelist
						eleWL=$2
						set -- "$1" "7";;
				2	)	[ "$hostedBL" = "on" ] && get_hosted_list $hostedBLUrl blacklist;;
				3	)	[ "$hostedWL" = "on" ] && get_hosted_list $hostedWLUrl whitelist
						eleWL=$2
						set -- "$1" "7"
						[ "$hostedBL" = "on" ] && get_hosted_list $hostedBLUrl blacklist;;
				4	)	[ "$hostedWCBL" = "on" ] && get_hosted_list $hostedWCBLUrl wc_blacklist;;
				5	)	[ "$hostedWL" = "on" ] && get_hosted_list $hostedWLUrl whitelist
						eleWL=$2
						set -- "$1" "7"
						[ "$hostedWCBL" = "on" ] && get_hosted_list $hostedWCBLUrl wc_blacklist;;
				6	)	[ "$hostedBL" = "on" ] && get_hosted_list $hostedBLUrl blacklist
						[ "$hostedWCBL" = "on" ] && get_hosted_list $hostedWCBLUrl wc_blacklist;;
				7	)	[ "$hostedWL" = "on" ] && get_hosted_list $hostedWLUrl whitelist
						[ "$hostedBL" = "on" ] && get_hosted_list $hostedBLUrl blacklist
						[ "$hostedWCBL" = "on" ] && get_hosted_list $hostedWCBLUrl wc_blacklist;;
			esac
			echo
			sprl=
		fi

		case "$2" in
			1|3|5|7) 	echo " processing whitelist"
						edited_whitelist=
						trim_file "${DIVERSION_DIR}/list/whitelist"
						/opt/bin/grep "^[^#]" "${DIVERSION_DIR}/list/whitelist" | awk '{print $1}' | sed -e 's/^/ /;s/$/$/' >"${DIVERSION_DIR}/list/whitelist.tmp"
						/opt/bin/grep "^[^#]" "${DIVERSION_DIR}/list/whitelist" | awk '{print $1}' | sed -e 's/^/ /;s/$/ /' >>"${DIVERSION_DIR}/list/whitelist.tmp"
						echo ' localhost.localdomain$' >>"${DIVERSION_DIR}/list/whitelist.tmp"
						echo ' localhost.localdomain ' >>"${DIVERSION_DIR}/list/whitelist.tmp"
						for wlist in /jffs/addons/shared-whitelists/shared-*-whitelist; do
							if [ -s "$wlist" ] && [ "$wlist" != "/jffs/addons/shared-whitelists/shared-Diversion-whitelist" ]; then
								echo " including $wlist"
								[ -s "$wlist" ] && /opt/bin/grep "^[^#]" "$wlist" | sed 's#http[s]*://##;s#/.*##;s/^[ \t]*//;s/^/ /;s/$/$/' >>"${DIVERSION_DIR}/list/whitelist.tmp"
								[ -s "$wlist" ] && /opt/bin/grep "^[^#]" "$wlist" | sed 's#http[s]*://##;s#/.*##;s/^[ \t]*//;s/^/ /;s/$/ /' >>"${DIVERSION_DIR}/list/whitelist.tmp"
							fi
						done
						if [ -s "${DIVERSION_DIR}/list/tmp_hardcoded_whitelist" ]; then
							echo " including hardcoded whitelist"
							/opt/bin/grep "^[^#]" "${DIVERSION_DIR}/list/tmp_hardcoded_whitelist" >>"${DIVERSION_DIR}/list/whitelist.tmp"
							/opt/bin/grep "^[^#]" "${DIVERSION_DIR}/list/tmp_hardcoded_whitelist" | sed -e 's/\$/ /' >>"${DIVERSION_DIR}/list/whitelist.tmp"
						fi
						sort -u "${DIVERSION_DIR}/list/whitelist.tmp" -o "${DIVERSION_DIR}/list/whitelist.tmp"
						sed -i 's/\./\\./g' "${DIVERSION_DIR}/list/whitelist.tmp"

						[ "$bfFs" = "on" ] && blist='blockinglist blockinglist_fs' || blist='blockinglist'
						for list in $blist; do
							echo " removing entries in $list"
							cp "${DIVERSION_DIR}/list/$list" "${DIVERSION_DIR}/list/${list}.temp"
							/opt/bin/grep -vf "${DIVERSION_DIR}/list/whitelist.tmp" "${DIVERSION_DIR}/list/${list}.temp" >"${DIVERSION_DIR}/list/$list"
							rm -f "${DIVERSION_DIR}/list/${list}.temp"
						done

						if [ -s "/jffs/addons/shared-whitelists/shared-Diversion-whitelist" ]; then
							/opt/bin/grep "^[^#]" "${DIVERSION_DIR}/list/whitelist" | awk '{print $1}' > "${DIVERSION_DIR}/list/shared-Diversion-whitelist.tmp"
							if [ -s "${DIVERSION_DIR}/list/tmp_hardcoded_whitelist" ]; then
								/opt/bin/grep "^[^#]" "${DIVERSION_DIR}/list/tmp_hardcoded_whitelist" | sed 's/^ *//g;s/$$//g' >>"${DIVERSION_DIR}/list/shared-Diversion-whitelist.tmp"
							fi
							sort -u "${DIVERSION_DIR}/list/shared-Diversion-whitelist.tmp" >/jffs/addons/shared-whitelists/shared-Diversion-whitelist

							if [ -f "/jffs/scripts/firewall" ] && grep -q "sh /jffs/scripts/firewall" /jffs/scripts/firewall-start 2> /dev/null; then
								echo
								echo " updated shared-Diversion-whitelist"
								echo " refreshing Skynet to whitelist domains in"
								echo " shared-Diversion-whitelist"

								if [ -f "/tmp/skynet.lock" ]; then
									echo
									echo "${INFO} Skynet lockfile detected"
									i=16
									until [ "$i" -eq "0" ]; do
										i=$((i-1))
										if [ -f "/tmp/skynet.lock" ]; then
											echo "${INFO} Waiting for Skynet to finish task..."
											sleep 2
										else
											i=0
										fi
									done
									if [ -f "/tmp/skynet.lock" ]; then
										echo
										echo "${NOK} Unable to refresh Skynet to whitelist"
										echo "${SPACE} domains in shared-Diversion-whitelist."
										echo
										echo "${SPACE} Restart Skynet manually to immediately"
										echo "${SPACE} include the new whitelisted domains."
										echo
									fi
								fi
								if [ ! -f "/tmp/skynet.lock" ]; then
									sh /jffs/scripts/firewall whitelist refresh >/dev/null 2>&1
									echo " shared-Diversion-whitelist refreshed in Skynet"
								fi
							fi
						fi

						rm -f "${DIVERSION_DIR}/list/whitelist.tmp" "${DIVERSION_DIR}/list/shared-Diversion-whitelist.tmp"
						;;
		esac

		rm -f "${DIVERSION_DIR}/list/whitelist.tbr"
		create_wl_tbr(){
			if [ ! -f "${DIVERSION_DIR}/list/whitelist.tbr" ]; then
				/opt/bin/grep "^[^#]" "${DIVERSION_DIR}/list/whitelist" | awk '{print $1}' \
				| awk '!/[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]* |\*/' | sed -e 's/^/ /' >"${DIVERSION_DIR}/list/whitelist.tbr"

				for wlist in /jffs/addons/shared-whitelists/shared-*-whitelist; do
					if [ -s "$wlist" ] && [ "$wlist" != "/jffs/addons/shared-whitelists/shared-Diversion-whitelist" ]; then
						/opt/bin/grep "^[^#]" "$wlist" | sed 's#http[s]*://##;s#/.*##;s/^[ \t]*//;s/^/ /' >>"${DIVERSION_DIR}/list/whitelist.tbr"
					fi
				done

				if [ -f "${DIVERSION_DIR}/list/tmp_essential_whitelist" ]; then
					cat "${DIVERSION_DIR}/list/tmp_essential_whitelist" >>"${DIVERSION_DIR}/list/whitelist.tbr"
				fi

				sed -i 's/\./\\./g;s/$$//g' "${DIVERSION_DIR}/list/whitelist.tbr"
				sort -u "${DIVERSION_DIR}/list/whitelist.tbr" -o "${DIVERSION_DIR}/list/whitelist.tbr"
			fi
		}

		case "$2" in
			2|3|6|7) 	create_wl_tbr
						echo " processing blacklist"
						edited_blacklist=
						trim_file "${DIVERSION_DIR}/list/blacklist"
						convert_to_ip $blockingIP "${DIVERSION_DIR}/list/blacklist"

						rm -f "${DIVERSION_DIR}/list/blacklist.removed"

						for line in $(cat "${DIVERSION_DIR}/list/whitelist.tbr"); do
							if grep -q " $line$\| $line " "${DIVERSION_DIR}/list/blacklist"; then
								echo " $line" | sed 's/\\//g' >>"${DIVERSION_DIR}/list/blacklist.removed"
								sed -i "/ $line/d" "${DIVERSION_DIR}/list/blacklist"
							fi
						done

						if [ -s "${DIVERSION_DIR}/list/blacklist.removed" ]; then
							echo " whitelisted domain(s) removed from the blacklist:${RED}"
							column "${DIVERSION_DIR}/list/blacklist.removed"
							echo "${NC}"
						fi
						;;
		esac

		case "$2" in
			4|5|6|7	)	create_wl_tbr
						echo " processing wildcard-blacklist"
						edited_wc_blacklist=

						trim_file "${DIVERSION_DIR}/list/wc_blacklist"

						rm -f "${DIVERSION_DIR}/list/wc_blacklist.removed"

						for line in $(cat "${DIVERSION_DIR}/list/whitelist.tbr"); do
							if grep -q "^$line$\|^$line #" "${DIVERSION_DIR}/list/wc_blacklist"; then
								echo " $line" | sed 's/\\//g' >>"${DIVERSION_DIR}/list/wc_blacklist.removed"
								sed -i "/^$line/d" "${DIVERSION_DIR}/list/wc_blacklist"
							fi
						done

						if [ -s "${DIVERSION_DIR}/list/wc_blacklist.removed" ]; then
							echo " whitelisted domain(s) removed from the wildcard-blacklist:${RED}"
							column "${DIVERSION_DIR}/list/wc_blacklist.removed"
							echo "${NC}"
						fi
						;;
		esac

		rm -f "${DIVERSION_DIR}/list/whitelist.tbr"

		write_conf_file

		case "$2" in
			1|2|3	)	kill -HUP $(pidof dnsmasq);;
			4|5|6|7	)	restart_DNSMASQ;;
		esac

		if [ "$edited_whitelist" = "1" ] || [ "$edited_blacklist" = "1" ] || [ "$edited_wc_blacklist" = "1" ] || [ "$3" = "hosted" ]; then
			print_red_line;el_function
		fi

		[ "$eleWL" ] && set -- "$1" "$eleWL"
		case "$2" in
			1	)	set -- $2 "whitelist";;
			2	)	set -- $2 "blacklist";;
			3	)	set -- $2 "white + blacklist";;
			4	)	set -- $2 "wildcard list";;
			5	)	set -- $2 "wildcard + whitelist";;
			6	)	set -- $2 "wildcard + blacklist";;
			7	)	set -- $2 "all lists" $3;;
		esac

		case "$3" in
			sh	)	;;
			*	) 	lastAction=" processed $2"
					reload_menu;;
		esac
	fi
}

restore_file(){
	echo
	i=0
	for file in "${DIVERSION_DIR}/backup/"*$1; do
		if [ -f "$file" ]; then
			i=$((i+1))
			printf "%4s %s\n" "$i." "${file#$1/}"
			eval "fileSel$i=$file"
		fi
	done

	if [ "$i" -gt "0" ]; then
		while true; do
			printf "\\n Date format is YYYY-MM-DD_HH.MM\\n"
			printf "\\n Select file to restore [1-$i e=Exit] ";read -r number
			case "$number" in
						 [Ee]) 	exit_message;reload_menu;break;;
				  ''|*[!0-9]*) 	printf "\\n input is not a number\\n";;
			[1-9]|[1-9][0-9]*) 	if [ "$number" -gt "$i" ]; then
									printf "\\n input is outside file range\\n"
								else
									break
								fi;;
							*)	printf "\\n input is not an option\\n";;
			esac
		done

		restorefile="$(eval "echo \"\$fileSel$number\"")"
		cp -f "$restorefile" "${DIVERSION_DIR}/list/$1"
		printf "\\n file $restorefile\\n restored to ${DIVERSION_DIR}/list/$1\\n"
	else
		echo " No $1 files to restore found,"

		if [ -s "${DIVERSION_DIR}/list/${1}.txt" ]; then
			mv "${DIVERSION_DIR}/list/${1}.txt" "${DIVERSION_DIR}/list/${1}"
			echo " renamed existing ${1}.txt to ${1}"
		else
			cat <<-EOF > "${DIVERSION_DIR}/list/${1}"

			EOF
			echo " Created new empty ${1}"
		fi
	fi
}

cj_function(){
	printf " $NAME sets these cron jobs when service is on:\\n\\n"
	printf " Diversion_UpdateBL,\\n"
	printf " Diversion_UpdateBLTwo  ${RED_BG} a ${NC} is on, updates blocking list, (bi)weekly\\n"
	printf " Diversion_RotateLogs   ${RED_BG} l ${NC} is on, rotates log files, counts ads, daily\\n"
	printf " Diversion_CountAds     ${RED_BG} l ${NC} is on, counts ads, daily\\n"
	printf " Diversion_WeeklyStats  ${GREEN}stats${NC} is on, sends stats, weekly\\n"
	printf " Diversion_AutoBackup   ${GREEN}backup${NC} is on, sends backup files\\n"
	printf " Diversion_LocalBackup  ${GREEN}Local backup${NC} is on in ${RED_BG} d ${NC}\\n"
	printf " Diversion_UpdateCheck  ${GREEN}DivUn${NC} is on, checks for $NAME updates\\n"
	printf "\\n The following cron jobs are active (cru l):\\n"
	print_red_line
	if [ ! "$(ls -A /var/spool/cron/crontabs)" ] || [ ! -s "/var/spool/cron/crontabs/$(nvram get http_username)" ]; then
		echo " (there are no cron jobs set at the moment)"
		print_red_line
	else
		cru l | sed -e 's/^/ /'
		print_red_line
		echo " |  |  |  |  |   |   command to run #job_name#   |"
		echo " .  .  .  .  ....... day-of-week"
		echo " .  .  .  .......... month"
		echo " .  .  ............. day-of-month"
		echo " .  ................ hour"
		echo " ................... minute     ( * = every ... )"
	fi
	press_enter_to "return to menu"
}

sf_function(){
    list_files(){
        for file in "${1}/"$2*; do
            if [ -f "$file" ]; then
				printf "%4s %s\\n" "$i." "${file#$1/}" >>/tmp/div-SF
                eval "fileSel$i=\"$(echo -e "$file" | sed 's/\$/\\\$/' )\""
                i=$((i+1))
            elif [ ! -d "$file" ]; then
                echo "     no file(s) found"
            fi
        done
		[ -f /tmp/div-SF ] && column -or /tmp/div-SF
		rm -f /tmp/div-SF
    }
	i=1
	istart=1
	if [ -z "$1" ]; then
		printf " Select file content to show\\n"

		printf "\\n${GREEN}     $NAME config file:${NC}\\n"
		list_files "${DIVERSION_DIR}/.conf" diversion.conf

		if [ "$(ls -A ${DIVERSION_DIR}/custom)" ]; then
			printf "\\n${GREEN}     $NAME custom files:${NC}\\n"
			list_files "${DIVERSION_DIR}/custom"
		fi

		if [ "$(ls -A ${DIVERSION_DIR}/log)" ]; then
			printf "\\n${GREEN}     $NAME log files:${NC}\\n"
			list_files "${DIVERSION_DIR}/log"
		fi

		if [ "$(ls -A ${DIVERSION_DIR}/stats)" ]; then
			printf "\\n${GREEN}     $NAME stats files:${NC}\\n"
			list_files "${DIVERSION_DIR}/stats"
		fi

		if [ -s "${DIVERSION_DIR}/backup/diversion_stats-iphostleases" ]; then
			printf "\\n${GREEN}     $NAME stats client name backup:${NC}\\n"
			list_files "${DIVERSION_DIR}/backup" diversion_stats-iphostleases
		fi

		if [ -f "/opt/etc/init.d/S80pixelserv-tls" ]; then
			printf "\\n${GREEN}     pixelserv-tls start file:${NC}\\n"
			list_files /opt/etc/init.d S80pixelserv-tls
		fi

		printf "\\n${GREEN}     dnsmasq config file(s):${NC}\\n"
		list_files /etc dnsmasq.conf
		[ -f "${DIVERSION_DIR}/.conf/alternate-bf.conf" ] && list_files "${DIVERSION_DIR}/.conf" alternate-bf.conf

		printf "\\n${GREEN}     jffs config files:${NC}\\n"
		list_files /jffs/configs

		printf "\\n${GREEN}     jffs script files:${NC}\\n"
		list_files /jffs/scripts

		printf "\\n${GREEN}     jffs shared whitelists:${NC}\\n"
		list_files /jffs shared-

		printf "\\n${GREEN}     shell history file:${NC}\\n"
		list_files /home/root .ash_history

	elif [ "$1" = "rmlists" ]; then
		printf " Select file to delete:\\n"

		printf "\\n${GREEN}     whitelist backups:${NC}\\n"
		list_files "${DIVERSION_DIR}/backup" *-whitelist

		printf "\\n${GREEN}     blacklist backups:${NC}\\n"
		list_files "${DIVERSION_DIR}/backup" *-blacklist

		printf "\\n${GREEN}     wildcard-blacklist backups:${NC}\\n"
		list_files "${DIVERSION_DIR}/backup" *-wc_blacklist

		printf "\\n Date format is YYYY-MM-DD_HH.MM\\n"
	fi

	i=$((i-1))

	while true; do
		printf "\\n Select file [1-$i e=Exit] ";read -r number
		case "$number" in
					 [Ee]) 	exit_message;reload_menu;break;;
			  ''|*[!0-9]*) 	printf "\\n input is not a number\\n";;
		[1-9]|[1-9][0-9]*) 	if [ "$number" -gt "$i" ]; then
								printf "\\n input is outside file range\\n"
							else
								break
							fi;;
						*)	printf "\\n input is not an option\\n";;
		esac
	done

	showfile="$(eval "echo \"\$fileSel$number\"")"

	echo
	print_red_line

	printf "${GREEN} $showfile ${NC}has this content:\\n\\n"
	echo " START FILE, --- lines are not part of file"
	echo " ---------------------------------------------------"
	cat  "$showfile" | sed -e 's/^/ /'
	[ "$(wc -l < $showfile)" = "0" ] && printf "\\n"
	echo " ---------------------------------------------------"
	echo " END FILE"

	if [ "${showfile%/*}" = "${DIVERSION_DIR}/stats" ] || [ "$1" = "rmlists" ]; then
		while true; do
			printf "\\n Delete file now? [1=No 2=Yes] ";read -r continue
			case "$continue" in
				1)		break;;
				2)		rm "$showfile"
						echo
						echo " ${showfile##*/} deleted"
						break;;
				[Ee])	break;;
				*)		printf "\\n input is not an option\\n";;
			esac
		done
	else
		press_enter_to return
	fi
	print_red_line
	sf_function "$@"
}

sw_function(){

	if [ "$partitionsize" ]; then
		lastError=" $NAME does not manage swap partitions."
		reload_menu
	fi
	if grep -q 'do-not-check-swap' /jffs/scripts/post-mount; then
		echo "${ATTN} Found \"do-not-check-swap\" entry in"
		echo "${SPACE} /jffs/scripts/post-mount. $NAME and amtm"
		echo "${SPACE} will not auto-correct paths."
		echo
	fi
	echo " This manages the Swap file."
	echo " A Swap file is useful when the router runs out of"
	echo " memory (RAM). See router WebUI/Tools under Memory."
	echo
	if [ "$multipleswap" ]; then
		echo " Multiple swap files found, only one file is"
		echo " supported."
		echo

		findswap=$(find /tmp/mnt/*/*.swp 2> /dev/null)
		i=1; noad=
		if [ "$findswap" ]; then
			for swapfile in $findswap; do
				echo " $i. ${GREEN}$swapfile${NC} $(du -h "$swapfile" | awk '{print $1}')"
				eval swapfile$i="$swapfile"
				noad="${noad}${i} "
				i=$((i+1))
			done
			echo
		fi
		if [ "$(wc -l < /proc/swaps)" -ge "2" ]; then
			echo " Found in /proc/swaps, delete manually:"
			echo
			cat /proc/swaps
		fi
		if [ "$i" -gt "1" ]; then
			while true; do
				printf "\\n Enter swap file to delete [1-$((i-1)) e=Exit] ";read -r continue
				case "$continue" in
					[$noad]) 	sync; echo 3 > /proc/sys/vm/drop_caches
								swapoff -a
								eval rmswap="\$swapfile$continue"
								rm "$rmswap"
								reload_menu
								break;;
					[Ee])		reload_menu;break;;
					*)			printf "\\n input is not an option\\n";;
				esac
			done
		else
			press_enter_to "return to the menu"
			reload_menu
		fi
	elif [ -f "$swaplocation" ]; then
		printf " Swap file found at:\\n ${GREEN}$swaplocation${NC}\\n"
		while true; do
			printf "\\n Remove the Swap file? [1=Yes e=Exit] ";read -r continue
			case "$continue" in
				1)	echo " Removing the Swap file at $swaplocation"
					echo
					if [ -f "$swaplocation" ]; then
						sync; echo 3 > /proc/sys/vm/drop_caches
						swapoff "$swaplocation"
						rm -rf "$swaplocation"
						sed -i '\~swapon ~d' /jffs/scripts/post-mount
						lastAction=" Swap file removed from:\\n $swaplocation"
					else
						sed -i '\~swapon ~d' /jffs/scripts/post-mount
						lastError=" No Swap file found at\\n $swaplocation"
					fi
					reload_menu;break;;
			[Ee])	exit_message;reload_menu;break;;
				*)	printf "\\n input is not an option\\n";;
			esac
		done
	elif [ -z "$swaplocation" ]; then
		printf " No Swap file detected on system.\\n"
		while true; do
			printf "\\n Create a Swap file now? [1=Yes e=Exit] ";read -r continue
			case "$continue" in
				1)	print_red_line
					printf " Listing compatible device(s) for a Swap file:\\n\\n"

					i=1;noad=
					for mounted in $(/bin/mount | grep -E "ext2|ext3|ext4|tfat|exfat" | cut -d" " -f3); do
					  echo " $i. ${GREEN}$mounted${NC}"
					  eval mounts$i=$mounted
					  noad="${noad}${i} "
					  i=$((i+1))
					done

					if [ "$i" = "1" ]; then
						lastError=" No compatible devices available."
						reload_menu
					fi

					[ "$i" = "2" ] && devNo=1-1 || devNo="1-$((i-1))"
					while true; do
						printf "\\n Select device [$devNo e=Exit] ";read -r device
						case "$device" in
							[$noad])	break;;
							[Ee])		exit_message
										reload_menu;break;;
							*)			printf "\\n input is not an option\\n";;
						esac
					done

					eval swapDevice=\$mounts$device

					print_red_line
					echo " creating Swap file on:${GREEN} $swapDevice${NC}"

					while true; do
						printf "\\n Continue? [1=Yes e=Exit] ";read -r swaps
						case "$swaps" in
							1)	print_red_line
								echo " Select a Swap file size"
								echo
								echo " 1.   1GB"
								echo " 2.   2GB (recommended)"
								while true; do
									printf "\\n Enter size [1-2 e=Exit] ";read -r size
									case "$size" in
										1)	swapsize=1048576;break;;
										2)	swapsize=2097152;break;;
									 [Ee])	exit_message;reload_menu;break;;
										*)	printf "\\n input is not an option\\n";;
									esac
								done
								if [ -f "$swapDevice/myswap.swp" ]; then
									sync; echo 3 > /proc/sys/vm/drop_caches
									swapoff "$swapDevice/myswap.swp" 2>/dev/null
									rm -rf "$swapDevice/myswap.swp"
								fi
								if [ "$(df $swapDevice | xargs | awk '{print $11}')" -le "$swapsize" ]; then
									print_red_line
									echo " Not enough free space available on $swapDevice"
									echo
									press_enter_to "select another device"
									print_red_line
									sw_function
								fi
								print_red_line
								echo " Creating the Swap file, this will take some time"

								echo "${GRAY}"
								dd if=/dev/zero of="$swapDevice/myswap.swp" bs=1k count="$swapsize"
								mkswap "$swapDevice/myswap.swp"
								swapon "$swapDevice/myswap.swp"
								nvram set usb_idle_timeout=0
								echo "${NC}"

								sed -i "2i swapon $swapDevice/myswap.swp # Added by $NAME" /jffs/scripts/post-mount

								if [ -f "/jffs/scripts/unmount" ] && ! grep -q '&& swapoff \$1/myswap.swp' /jffs/scripts/unmount; then
									sed -i '\~swapon ~d' /jffs/scripts/unmount
									trim_file /jffs/scripts/unmount
									echo '[ "$(/usr/bin/find $1/myswap.swp 2> /dev/null)" ] && swapoff $1/myswap.swp # Added by Diversion' >>/jffs/scripts/unmount
								fi

								lastAction=" Swap file created at:\\n $swapDevice/myswap.swp"
								[ -z "$skiprl" ] && reload_menu
								break;;
						[Ee])	exit_message;reload_menu;break;;
							*) printf "\\n input is not an option\\n\\n";;
						esac
					done;break;;
			 [Ee])	exit_message;reload_menu;break;;
				*)	printf "\\n input is not an option\\n";;
			esac
		done
	else
		lastError=" No Swap file to remove found."
		reload_menu
	fi
}

sh_function(){
	printf " $NAME can keep a history of shell commands\\n even after rebooting the router.\\n"

	if [ "$shHistory" = "on" ] ; then
		printf "\\n The content of .ash_history can be viewed in ${RED_BG} sf ${NC}\\n"
		printf "\\n When resetting the shell history, log out and back\\n in with your SSH client to clear its history.\\n"
		printf "\\n 1. ${RED}Disable${NC} keeping the shell history\\n"
		printf " 2. Reset shell history.\\n"
		shsel=2
	else
		printf "\\n 1. ${GREEN}Enable${NC} keeping the shell history\\n"
		shsel=1
	fi
	while true; do
		printf "\\n Enter selection: [1-$shsel e=Exit] ";read -r continue
		case "$continue" in
			1)	if [ "$shHistory" = "on" ] ; then
					shHistory=off
					rm -f /jffs/.ash_history /home/root/.ash_history /tmp/div_sort_ash
					lastAction=" Shell history disabled."
				else
					shHistory=on
					sh /opt/share/diversion/file/ash-history.div &
					lastAction=" Shell history enabled."
				fi
				write_conf_file
				break;;
			2)	if [ "$shHistory" = "on" ] ; then
					rm -f /jffs/.ash_history /home/root/.ash_history /tmp/div_sort_ash
					sh /opt/share/diversion/file/ash-history.div &
					lastAction=" shell history reset."
				else
					lastError=" Shell history is not enabled."
				fi
				break;;
		 [Ee])	exit_message;break;;
			*)	printf "\\n input is not an option\\n";;
		esac
	done
}

c_backup(){
	print_red_line
	printf "${INFO} Backup essential files to email.\\n${SPACE} Select files and how often to backup.\\n"
	printf "\\n${SPACE} Backup to email is independent of the local\\n${SPACE} backup function in ${RED_BG} d ${NC}\\n\\n"
	if [ -z "$backup" ] || [ "$backup" = "off" ]; then
		printf " 1. ${GREEN}Enable${NC} Auto backup to email $buSState\\n"
	else
		printf " 1. Auto backup settings [${GREEN}$buFrequency${NC},${GREEN}$buType${NC},${GREEN}$buAs${NC},${GREEN}$buCompression${NC}]\\n"
	fi
	printf " 2. Run manual backup now\\n"

	while true; do
		printf "\\n Enter selection [1-2 e=Exit] ";read -r continue
		case "$continue" in
			1)	read_conf_file
				if [ "$backup" = "on" ]; then
					print_red_line
					printf " Auto backup settings\\n"
					printf " 1. ${RED}Disable${NC} auto backup\\n"
					printf " 2. Change settings\\n"
					while true; do
						printf "\\n Enter selection [1-2 e=Exit] ";read -r confirm
						case "$confirm" in
							1)	backup=off
								write_conf_file
								restart_DNSMASQ
								lastAction=" Auto backup disabled";break;;
							2)	c_backup_settings
								write_conf_file
								restart_DNSMASQ
								lastAction=" Auto backup settings changed";break;;
						 [Ee])	exit_message;break;;
							*)	printf "\\n input is not an option\\n";;
						esac
					done

				else
					check_email_conf_file
					get_file backup.div check
					if [ -z "$buFrequency" ]; then
						buFrequency=weekly
						buType=Essential
						buAs=compressed
						buCompression=tar.gz
						c_backup_settings
					fi
					backup=on
					write_conf_file
					restart_DNSMASQ
					lastAction=" Auto backup enabled"
					reload_menu

				fi
				break;;
			2)	c_manual_backup;reload_menu;break;;
		 [Ee])	exit_message;reload_menu;break;;
			*)	printf "\\n input is not an option\\n";;
		esac
	done
}

c_backup_settings(){
	print_red_line
	printf " Select when to send the backup (${GREEN}$buFrequency${NC})\\n\\n"
	printf " 1. weekly on [${GREEN}$(echo $bfUpdateDOW | sed 's/,.*//') @ $((bfUpdateHour-1)):50${NC}] (default)\\n"
	printf " 2. monthly on first [${GREEN}$(echo $bfUpdateDOW | sed 's/,.*//') @ $((bfUpdateHour-1)):50${NC}]\\n"
	while true; do
		printf "\\n Set when to backup [1-2 d=default] ";read -r backupfreq
		case "$backupfreq" in
			1)	buFrequency=weekly;break;;
			2)	buFrequency=monthly;break;;
			d)	buFrequency=weekly;break;;
			*)	printf "\\n input is not an option\\n";;
		esac
	done
	print_red_line
	printf " Select what to backup,\\n currently set to [${GREEN}$buType${NC}]\\n\\n"
	printf " - Key-files: Key $NAME files:\\n   blacklist, wildcard blacklist and whitelist,\\n   hostslist(s), config files and pielserv-tls certs\\n"
	printf " - Key+logs: Key $NAME files plus the\\n   dnsmasq log files.\\n"
	printf " - Custom: Set your own files/folders after\\n   selection in this file:\\n"
	printf "   ${DIVERSION_DIR}/custom/custom_backup_settings.txt\\n\\n"
	printf "   Make sure the attachment is not too big or\\n   else it might be too large for your inbox.\\n\\n"
	printf " 1. Key-files (default)\\n 2. Key+logs\\n 3. Custom\\n"
	while true; do
		printf "\\n Set what to backup [1-3 d=default] ";read -r backupw
		case "$backupw" in
			1)	buType=Key-files;break;;
			2)	buType=Key+logs;break;;
			3)	buType=Custom;c_write_backup_settings_file
				write_backup_exclude_file;break;;
			d)	buType=Key-files;break;;
			*)	printf "\\n input is not an option\\n";;
		esac
	done
	print_red_line
	printf " Select how to backup, currently set to [${GREEN}$buAs${NC}]\\n\\n"
	printf " - compressed: all files as one dated compressed\\n   archive\\n"
	printf " - files: uncompressed files, .txt is appended\\n   to non-txt filename(s), folders are compressed\\n\\n"
	printf " 1. compressed (default)\\n 2. files\\n"
	while true; do
		printf "\\n Set how to backup [1-2 d=default] ";read -r backuph
		case "$backuph" in
			1)	buAs=compressed;break;;
			2)	buAs=files;break;;
			d)	buAs=compressed;break;;
			*)	printf "\\n input is not an option\\n";;
		esac
	done
	print_red_line
	printf " Select compression type, currently set to: ${GREEN}$buCompression${NC}\\n\\n"
	printf " - tar.gz: as one dated tar.gz archive.\\n"
	printf " - zip:    as one dated zip archive.\\n\\n"
	printf " 1. tar.gz (default)\\n 2. zip\\n"
	while true; do
		printf "\\n Set compression type [1-2 d=default] ";read -r backupc
		case "$backupc" in
			1)	buCompression=tar.gz;break;;
			2)	check_install_zip;break;;
			d)	buCompression=tar.gz;break;;
			*)	printf "\\n input is not an option\\n";;
		esac
	done

	write_backup_exclude_file

}

check_install_zip(){
	if [ -z "$(which zip)" ]; then
		printf "\\n ${INFO} Installing required $entVersion package: zip\\n"
		# make sure we use the latest version
		echo "${GRAY}"
		opkg update >/dev/null
		opkg install zip
		echo "${NC}"
		if [ "$(which zip)" ]; then
			printf " $OK package zip installed\\n\\n"
			buCompression=zip
		else
			buCompression=tar.gz
			printf " $NOK failed to install Entware package zip\\n"
			printf " $SPACE tar.gz has been auto-selected.\\n"
			press_enter_to acknowledge
		fi
	fi
}

c_manual_backup(){
	check_email_conf_file
	get_file backup.div check
	write_backup_exclude_file
	print_red_line
	[ -z "$buCompression" ] && buCompression=tar.gz
	if [ "$buCompression" = zip ]; then
		check_install_zip
		write_conf_file
	fi
	printf " This will send a backup of selected files.\\n"
	printf " Compressed sends one dated archive.\\n\\n Change compression type in the Auto settings.\\n"
	printf " Individual files are not compressed but\\n folders will be.\\n\\n"
	printf " - Key-files: Key $NAME files:\\n   black and whitelist, config files and ps certs\\n"
	printf " - Key+logs: Key $NAME files plus the\\n   dnsmasq log files.\\n"
	printf " - Custom: Set your own files/folders after\\n   selection in this file (same as Auto backup):\\n"
	printf "   ${DIVERSION_DIR}/custom/custom_backup_settings.txt\\n\\n"

	printf " Select what to send as backup now:\\n\\n"
	printf " 1. Key-files as $buCompression archive\\n"
	printf " 2. Key-files as individual files\\n"

	printf " 3. Key+logs files as $buCompression archive\\n"

	printf " 4. Custom files as $buCompression archive\\n"
	printf " 5. Custom files as individual files\\n"
	while true; do
		printf "\\n Select what to backup now [1-5 e=Exit] ";read -r continue
		case "$continue" in
					# positional parameters used to run $buFile:
					# $1 = Backup type (Key-files, Key+logs Custom), $2 = file type (files, compressed) $3 = compress method (zip, tar.gz)
			1)		print_red_line
					echo "${GRAY}"
					sh "${DIVERSION_DIR}/file/backup.div" Key-files compressed $buCompression
					echo "${NC}"
					press_enter_to "return to menu"
					lastAction=" sent Key-files backup as $buCompression";break;;
			2)		print_red_line
					echo "${GRAY}"
					sh "${DIVERSION_DIR}/file/backup.div" Key-files files $buCompression
					echo "${NC}"
					press_enter_to "return to menu"
					lastAction=" sent Key-files backup as files";break;;
			3)		print_red_line
					echo "${GRAY}"
					sh "${DIVERSION_DIR}/file/backup.div" Key+logs compressed $buCompression
					echo "${NC}"
					press_enter_to "return to menu"
					lastAction=" sent Key+logs backup as $buCompression";break;;
			4)		if [ ! -f "${DIVERSION_DIR}/custom/custom_backup_settings.txt" ]; then
						c_write_backup_settings_file
						printf "\\n Set your own files/folders first in this file:\\n"
						printf " ${DIVERSION_DIR}/custom/custom_backup_settings.txt\\n"
						printf " then run this function again.\\n"
						press_enter_to "return to menu"
						reload_menu
					fi
					print_red_line
					echo "${GRAY}"
					sh "${DIVERSION_DIR}/file/backup.div" Custom compressed $buCompression
					echo "${NC}"
					press_enter_to "return to menu"
					lastAction=" sent Custom backup files as $buCompression";break;;
			5)		if [ ! -f "${DIVERSION_DIR}/custom/custom_backup_settings.txt" ]; then
						c_write_backup_settings_file
						printf "\\n Set your own files/folders first in this file:\\n"
						printf " ${DIVERSION_DIR}/custom/custom_backup_settings.txt\\n"
						printf " then run this function again.\\n"
						press_enter_to "return to menu"
						reload_menu
					fi
					print_red_line
					echo "${GRAY}"
					sh "${DIVERSION_DIR}/file/backup.div" Custom files $buCompression
					echo "${NC}"
					press_enter_to "return to menu"
					lastAction=" sent Custom backup files as files";break;;
			[Ee])  	reload_menu;break;;
			*)		printf "\\n input is not an option\\n";;
		esac
	done
}

c_write_backup_settings_file(){
	if [ ! -f "${DIVERSION_DIR}/custom/custom_backup_settings.txt" ]; then
		cat <<-EOF > "${DIVERSION_DIR}/custom/custom_backup_settings.txt"
		### Custom backup to email settings file ###
		# This file will not be overwritten by $NAME once it exists.
		# generated by $NAME $VERSION
		#
		###  Edit this file and make sure you have set        ###
		###  Auto backup settings what to backup to "Custom"  ###
		#
		# You may use comments, the variables below and wildcards in this file.
		#
		# Use variable \${DIVERSION_DIR} for path to $NAME directory.
		# Example for blacklist:
		# \${DIVERSION_DIR}/list/blacklist
		#
		# To backup a folder, use no slash at end of foldername.
		# Example for the /jffs directory:
		# /jffs
		#
		# To backup all files in a folder, use a wildcard.
		# Example for the /jffs/scripts/ directory:
		# /jffs/scripts/*
		#
		# Be aware that all non *.txt files are appended with it.
		# Use the "zip" setting when backing up files with .sh ending
		# or your mail provider may reject the file (even though it is renamed as *.txt)
		#
		# Add your backup settings below,
		# without the comment character (#) for your backup entries



		EOF
	fi
}

write_backup_exclude_file(){
	if [ ! -f "${DIVERSION_DIR}/custom/backup_exclude.txt" ]; then
		cat <<-EOF > "${DIVERSION_DIR}/custom/backup_exclude.txt"
		### Backup to email file excluding file ###
		# This file will not be overwritten by $NAME once it exists.
		# generated by $NAME $VERSION
		#
		###  Edit this file if you want to      ###
		###  exclude more files in the backup.  ###
		#
		# You may use comments, the variables below and wildcards in this file.
		#
		# Use variable \${DIVERSION_DIR} for path to $NAME directory.
		# Example to exclude the blacklist:
		# \${DIVERSION_DIR}/list/blacklist
		#
		# To exclude a folder, use no slash at end of foldername.
		# Example for the /jffs directory:
		# /jffs
		#
		# To exclude files in a folder, use a wildcard.
		# Example for the /jffs/scripts/ directory:
		# /jffs/scripts/*
		#
		#
		# Add your file excludes below with full file path,
		# without the comment character (#) for your exclusions
		\${DIVERSION_DIR}/list/blockinglist
		\${DIVERSION_DIR}/list/blockinglist_fs
		\${DIVERSION_DIR}/backup/hostsfile*
		\${DIVERSION_DIR}/backup/blockinglist.pgl



		EOF
	fi
}

local_backup(){
	read_conf_file
	print_red_line
	localDivBackup=$(find /jffs/addons/diversion/${NAME}_*_local_backup*.tar.gz 2> /dev/null)
	if [ "$localDivBackup" ]; then
		localRestoreEdition=$(echo $localDivBackup | cut -d _ -f 2)
		localRestoreDate=$(echo $localDivBackup | cut -d _ -f 5-8 | sed "s~.tar.gz~~;s~_~ ~g;s~\.~:~g")
	fi

	if [ -z "$localBackup" ]; then
		echo "${INFO} This saves a backup of essential $NAME"
		echo "${SPACE} files to /jffs/addons/diversion"
		echo "${SPACE} for use when re-installing $NAME."
		printf "\\n${SPACE} This local backup is independent of the\\n${SPACE} backup to email function in ${RED_BG} c ${NC}\\n"
		echo
		[ "$localDivBackup" ] && printf "${INFO} Last $NAME $localRestoreEdition local backup in\\n${SPACE} /jffs/addons/diversion is from\\n${SPACE} ${GREEN}$localRestoreDate${NC}\\n\\n"
		printf " 1. ${GREEN}Enable${NC} scheduled local backup\\n"
	else
		[ "$localDivBackup" ] && printf "${INFO} Last $NAME $localRestoreEdition local backup in\\n${SPACE} /jffs/addons/diversion is from\\n${SPACE} ${GREEN}$localRestoreDate${NC}\\n\\n"
		printf " 1. Local backup settings ${GREEN}$lBuFrequency${NC}\\n"
	fi
	printf " 2. Run manual local backup now\\n"
	ldbo=;lbo=2
	if [ "$localDivBackup" ]; then
		printf " 3. Delete backup file from ${GREEN}$localRestoreDate${NC}\\n"
		ldbo=3;lbo=3
	fi
	while true; do
		printf "\\n Enter selection [1-$lbo e=Exit] ";read -r continue
		case "$continue" in
			1)			if [ "$localBackup" = "on" ]; then
							print_red_line
							printf " 1. ${RED}Disable${NC} scheduled local backup\\n"
							printf " 2. Change backup frequency ${GREEN}$lBuFrequency${NC}\\n"
							while true; do
								printf "\\n Enter selection [1-2 e=Exit] ";read -r confirm
								case "$confirm" in
									1)		localBackup=
											lBuFrequency=
											write_conf_file
											cru d Diversion_LocalBackup
											lastAction=" Local backup disabled"
											reload_menu;break;;
									2)		print_red_line
											printf " Set backup frequency\\n\\n"
											printf " 1. weekly\\n"
											printf " 2. monthly\\n"
											while true; do
												printf "\\n Enter selection [1-2 e=Exit] ";read -r confirm
												case "$confirm" in
													1)	lBuFrequency=weekly
														cru d Diversion_LocalBackup
														cru a Diversion_LocalBackup "10 $((bfUpdateHour+1)) * * $(echo $bfUpdateDOW | sed 's/,.*//') sh ${DIVERSION_DIR}/file/backup.div local"
														break;;
													2)	lBuFrequency=monthly
														cru d Diversion_LocalBackup
														cru a Diversion_LocalBackup "10 $((bfUpdateHour+1)) * * $(echo $bfUpdateDOW | sed 's/,.*//') [ $(echo '"$(date +%d)" -le "07"') ] && sh ${DIVERSION_DIR}/file/backup.div local"
														break;;
												[Ee])	exit_message;reload_menu;break;;
													*)	printf "\\n input is not an option\\n";;
												esac
											done
											write_conf_file
											lastAction=" Changed local backup frequency to $lBuFrequency"
											reload_menu;break;;
									[Ee])	exit_message;reload_menu;break;;
									*)		printf "\\n input is not an option\\n";;
								esac
							done
						else
							print_red_line
							printf " Set backup frequency\\n\\n"
							printf " 1. weekly\\n"
							printf " 2. monthly\\n"
							while true; do
								printf "\\n Enter selection [1-2 e=Exit] ";read -r confirm
								case "$confirm" in
									1)	lBuFrequency=weekly
										cru a Diversion_LocalBackup "10 $((bfUpdateHour+1)) * * $(echo $bfUpdateDOW | sed 's/,.*//') sh ${DIVERSION_DIR}/file/backup.div local"
										break;;
									2)	lBuFrequency=monthly
										cru a Diversion_LocalBackup "10 $((bfUpdateHour+1)) * * $(echo $bfUpdateDOW | sed 's/,.*//') [ $(echo '"$(date +%d)" -le "07"') ] && sh ${DIVERSION_DIR}/file/backup.div local"
										break;;
								[Ee])	exit_message;reload_menu;break;;
									*)	printf "\\n input is not an option\\n";;
								esac
							done
							get_file backup.div check >/dev/null
							localBackup=on
							write_conf_file
							lastAction=" Local $lBuFrequency backup enabled"
							reload_menu
						fi
						break;;
			2)			get_file backup.div check >/dev/null
						echo "${GRAY}"
						sh "${DIVERSION_DIR}/file/backup.div" local
						echo "${NC}"
						newLocalDivBackup=$(find /jffs/addons/diversion/${NAME}_*_local_backup*.tar.gz 2> /dev/null)
						if [ "$newLocalDivBackup" ]; then
							newLocalRestoreDate=$(echo $newLocalDivBackup | cut -d _ -f 5-8 | sed "s~.tar.gz~~;s~_~ ~g;s~\.~:~g")
							if [ "$localDivBackup" ]; then
								if [ "$localDivBackup" != "$newLocalDivBackup" ]; then
									lastAction=" Local backup saved to\\n /jffs/addons/diversion ($newLocalRestoreDate)"
								else
									lastError=" Failed to create local backup"
								fi
							else
								lastAction=" Local backup saved to\\n /jffs/addons/diversion ($newLocalRestoreDate)"
							fi
						else
							lastError=" Failed to create local backup"
						fi
						sleep 1
						reload_menu;break;;
			[$ldbo])	print_red_line
						echo " Are you sure you want to delete the backup?"
						continue_dialog
						[ -f "$localDivBackup" ] && rm "$localDivBackup"
						lastAction=" Local backup file deleted"
						reload_menu;break;;
			[Ee])		exit_message;reload_menu;break;;
			*)			printf "\\n input is not an option\\n";;
		esac
	done
}

remove_diversion(){
	print_red_line
	remove_when_empty(){ [ "$(sed '/^[[:space:]]*$/d; /#!\/bin\/sh/d' "$1" | wc -c)" = 0 ] && rm "$1";}
	printf "${NOK} Sorry to see you go!\\n\\n"
	if grep -q "^swapon .* by Diversion" /jffs/scripts/post-mount 2>/dev/null; then
		swaplocation="$(grep -E "^swapon .* by Diversion" /jffs/scripts/post-mount | awk '{print $2}')"
		printf " There is a Swap file created by $NAME at:\\n $swaplocation\\n"
		while true; do
			printf "\\n Remove the Swap file? [1=Yes 2=No] ";read -r continue
			case "$continue" in
				1)	echo " Removing the Swap file at $swaplocation"
					echo
					if [ -f "$swaplocation" ]; then
						sync; echo 3 > /proc/sys/vm/drop_caches
						swapoff "$swaplocation"
						rm -rf "$swaplocation"
					fi
					sed -i '\~swapon ~d' /jffs/scripts/post-mount
					sed -i '/&& swapoff/d' /jffs/scripts/unmount
					printf " Swap file removed from:\\n $swaplocation\\n\\n"
					break;;
				2)	break;;
				*)	printf "\\n input is not an option\\n";;
			esac
		done
	fi

	localDivBackup=$(find /jffs/addons/diversion/${NAME}_*_local_backup*.tar.gz 2> /dev/null)
	if [ "$localDivBackup" ]; then
		print_red_line
		localRestoreEdition=$(echo $localDivBackup | cut -d _ -f 2)
		localRestoreDate=$(echo $localDivBackup | cut -d _ -f 5-8 | sed "s~.tar.gz~~;s~_~ ~g;s~\.~:~g")
		printf " There is a local $NAME $localRestoreEdition backup at\\n /jffs/addons/diversion/\\n for use when re-installing $NAME.\\n"
		printf "\\n The local backup is from ${GREEN}$localRestoreDate${NC}\\n"
		while true; do
			printf "\\n Remove the local backup? [1=No 2=Yes] ";read -r continue
			case "$continue" in
				1)	break;;
				2)	print_red_line
					echo " Are you sure you want to delete the backup?"
					while true; do
						printf "\\n Remove local backup file? [1=No 2=Yes] ";read -r continue
						case "$continue" in
							1)	break;;
							2)	[ -f "$localDivBackup" ] && rm "$localDivBackup"
								printf "\\n Local backup file deleted\\n"
								break;;
							*)	printf "\\n input is not an option\\n\\n";;
						esac
					done
					break;;
				*)	printf "\\n input is not an option\\n";;
			esac
		done
	fi
	read_conf_file
	[ "$psState" = "on" ] && on_off_pixelserv off
	DIVERSION_STATUS=disabled
	write_conf_file
	restart_DNSMASQ
	echo
	echo "${OK} $NAME services stopped"
	sleep 3

	sed -i '/post-conf.div/d' /jffs/scripts/dnsmasq.postconf
	remove_when_empty /jffs/scripts/dnsmasq.postconf
	if [ -f "/jffs/scripts/update-notification" ] && grep -q "FRIENDLY_ROUTER_NAME" /jffs/scripts/update-notification; then
		rm -f /jffs/scripts/update-notification
	fi
	sed -i '/diversion unmount/d' /jffs/scripts/unmount
	remove_when_empty /jffs/scripts/unmount
	rm -f /jffs/addons/shared-whitelists/shared-Diversion-whitelist /jffs/.ash_history /home/root/.ash_history /tmp/div_sort_ash
	[ "$(ls -A /jffs/addons/shared-whitelists)" ] || rm -rf /jffs/addons/shared-whitelists

	if [ "$(nvram get enable_acc_restriction)" = "1" ]; then
		if "$(nvram get restrict_rulelist)" | grep -q "$psIP>1"; then
			nvram set restrict_rulelist=$(nvram get restrict_rulelist | sed "s|<1>$psIP>1||g")
		fi
		if "$(nvram get restrict_rulelist)" | grep -q "$aBFIP>1"; then
			nvram set restrict_rulelist=$(nvram get restrict_rulelist | sed "s|<1>$aBFIP>1||g")
		fi
		nvram commit
		service restart_firewall >/dev/null
	fi

	rm -rf /opt/share/diversion
	rm -f /opt/var/log/dnsmasq.log*

	if [ "$rmentware" = "1" ]; then
		sed -i '/mount-entware.div/d' /jffs/scripts/post-mount
		remove_when_empty /jffs/scripts/post-mount
		rm -f /jffs/addons/diversion/mount-entware.div
		[ "$(ls -A /jffs/addons/diversion)" ] || rm -rf /jffs/addons/diversion
		if [ -f "/jffs/scripts/services-stop" ]; then
			/opt/etc/init.d/rc.unslung stop
			sed -i '/rc.unslung stop/d' /jffs/scripts/services-stop
			remove_when_empty /jffs/scripts/services-stop
		fi
		if [ -L /tmp/opt ]; then
			rm -f /tmp/opt 2> /dev/null
			rm -f /opt 2> /dev/null
		fi
		rm -rf "${entPath}"
		echo "${OK} Entware removed"

	elif [ "$rmentware" = "0" ]; then
		echo "${INFO} getting new Entware start script"
		newEss=/jffs/addons/diversion/mount-entware.div
		_curl https://diversion.ch/amtm/mount-entware.div -o "${newEss}".new
		if [ -s "${newEss}".new ]; then
			if grep -wq '^#bof' "${newEss}".new && grep -wq '^#eof' "${newEss}".new; then
				mv -f "${newEss}".new "${newEss}"
				echo "${OK} Entware start script downloaded: mount-entware.div"
				echo "${INFO} Script location is /jffs/addons/diversion/"
				echo
				dos_to_unix "${newEss}"
				chmod 0755 "${newEss}"
			else
				echo "${NOK} File is corrupt"
				echo "${INFO} Keeping existing Diversion file to start Entware"
				rm "${newEss}".new
				echo
			fi
		else
			echo "${NOK} Failed to download file"
			echo "${INFO} Keeping existing Diversion file to start Entware"
			echo
		fi
		if [ "$EN" -ge "2" ]; then
			echo "${GRAY}"
			opkg remove pixelserv-tls
			echo "${NC}"
			[ -d /opt/var/cache/pixelserv ] && rm -rf /opt/var/cache/pixelserv
		fi
		rm -f /opt/etc/init.d/rc.func.div
		rm -f "/opt/bin/$SELF"
	fi

	echo "${OK} $NAME removed"
	echo
	ascii_logo goodbye
	echo
	exit 0
}
#eof
